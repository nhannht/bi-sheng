
#+DOWNLOADED: screenshot @ 2020-12-04 13:43:14
[[file:_assets/2020-12-04_13-43-14_screenshot.png]]
#+begin_comment
* Project: Mile stone:  [3/14]
*** TODO Snort in general
*** DONE ICMP reflection -> hping
*** TODO ICMP packet injection -> ping of death
**** Use proxy, iptables, firewall to mitigate
**** TODO Scripting instead of use tool
*** DONE TCP bandwhich-consumming reflection base -> hping
*** DONE HTTP slow and low -> slowloris
*** TODO HTTP bandwhich consuming
*** TODO UDP bandwhich-consuming -> UDP flood
*** TODO NTP amplication
*** TODO DNS flood -reflection
*** TODO DNS amplication
*** Smurt attack
*** Fraggle attack
*** LOIC attack
*** HOIC attack
*** SNMP amplication
*** SSDP amplication
*** TODO Voip in general
*** TODO Aterisk in general
*** Ping of death
*** TODO same subnet asterisk deploy
*** TODO over internet asterisk deply
*** snort sam
*** Docker built
*** Preprocessor
*** snort plug
 #+end_comment
*** DVWA
*** None DOs attack:
**** XSS
**** SQL injection
     - 
* Lời mở đầu:
** Tầm quan trọng của IDS/IPS
** Sự nguy hiểm của tấn công DoS
** Tóm tắt nội dung:
  - Bài tiểu luận cho môn mạng máy tính nâng cao
  - Nội dung:
    - tìm hiểu về IDS/IPS (hệ thống phát hiện/phòng chống nỗ lực tấn công từ bên ngoài vào mạng lưới).
    - tìm hiểu về snort. Framework điểu hình về IDS/IPS
    - tìm hiểu về DoS/DDoS attack
    - Xây dựng hệ thống IDS/IPS với snort là trung tâm phòng thủ và DDos là kỹ thuật tấn công chính. GNS3 là môi trường thực nghiệm
** Tóm tắt hướng nghiên cứu:
*** Về lý thuyết: Snort sở hữu 1 hệ thống tài liệu phong phú và đầy đủ về nội dung lẫn ví dụ, nhóm chủ yếu sẽ tổng hợp lại ở các phần: 
**** Cách cài đặt
**** Cách set up các rules cơ bản để đối phó với từng kiểu tấn công DDoS
**** Cách sử dụng các extension mở rộng
*** Về DoS, hướng tân công này rất đa dạng, nhóm phân loại theo 2 hướng:
**** Dựa trên OSI model:
***** Layer 3 (Internet Protocol layer): ping flood, Ping of Death
***** Layer 4 (Transport layer): udp flood, tcp flood,....
***** Layer 5-6-7 (Application Layers): dùng https
**** Dựa trên hướng tân công:
***** Volumetric Attack: tạo ra một lượng lớn traffic để làm tràn bandwidth của hệ thống nạn nhân: TCP/UPD flood, NTP amplication, DNS amplication
***** Protocol Base Attack: dựa trên cách hoạt động của các giao thức ở layer 3 và layer 4.   Sync Flood, Ping of Death, DNS amplication, ...
***** Application Attack: hướng khai thác này phụ thuộc vào loại application. Mỗi chương trình sẽ có các nhược điểm riêng của nó. Như Apache sẽ bị tổn thương theo mặc định  (nếu không được điều chỉnh ) bởi HTTP low-and-slow attack, trong khi Nginx hay Nodejs sẽ không bị ảnh hưởng
*** Về thực nghiệm:
    - thực hiện các lab trên gns3,
    - các máy ảo dùng docker container: 1 Centos-server - server nạn nhân, 5 blackarch - botnet được điều khiển bởi attacker, 1 alpine linux - máy client thông thường 
    - Các thiết bị khác thuộc network: Cisco IOS router, 4 open-switch  của GNS3 team, 4 "máy ảo" mini do VPCS (không thật sự là hệ điều hành, chỉ có các tính năng như ping hay dhcp request) - đóng vai trò như client thông thường .
    - Nmap, Wireshark.
    - Mô phỏng các hướng DOS cụ thể: ping flood, ping of death, tcp syn-ack flood, udp flood, dns amplication, slow-and-slow http attack, http flood
    - Ngoài ra còn thêm vài kỹ thuật không phải DoS: sql injection,...
    - Mục tiêu: thể hiện được được truyền của đối tượng bị suy giảm mạnh, hoặc thậm chí đối tượng bị crash hoặc không truy cập được(web server). Thể hiện sự khác biệt về lượng traffic ở môi trường khoẻ mạnh và môi trường bị DDoS. Dùng Snort để phát hiện và log thông tin về các kiểu tấn công này. Nêu ra được giải pháp phòng thủ: có thể dùng snort extension, hoặc iptables, hoặc điều chỉnh trên chính apache2, trên các router.
    
* Cơ sở lý thuyết:

** IDS/IPS là gì:
   - Instrusion detection (hệ thống phát hiện thâm nhập) là một bộ các kỹ thuật và phương pháp được thiết kế để phát hiện những hành vi có thể gây nguy hại tới hệ thống (theo nghĩa toàn bộ hệ thống hoặc từng thành phần riêng lẻ). IDS rới vào 2 nhóm chính: Signature-based IDS (dựa trên chữ ký) và anomaly detection IDS (dựa trên sự bất thường ).
   - Những đối tượng xâm nhậm có chữ ký (như virus máy tính), có thể bị phát hiện bởi các phần mềm. IDS dựa trên chữ ký số hoạt động dưa trên việc đối chiếu nội dung của đối tượng với các chữ ký được lưu lại trên các database về malware hoặc các rule được người vận hành IDS thiết lập bằng tay -> Nếu phát hiện sẽ báo động
   - Ngược lại IDS based anamoly dựa trên các mô hình máy học để phát hiện các mối nguy hiểm[fn:1]. Phần này sẽ không đi sâu vào trong bài tiểu luận này
   - Snort thuộc nhóm 1: tức rules-signature IDS, tuy nhiên một số extension của snort hỗ trợ nhóm 2.
     
     - Theo trang [[https://cybersecurityventures.com/hackerpocalypse-cybercrime-report-2016/][cypersecurityventure.com]]: tổn hại do tội phạm mạng gây ra sẽ làm tổn thất 10,5 tỉ tỉ đô của thế giới vào năm 2025
     - Theo trang [[https://www.securitymagazine.com/articles/90493-cyber-attacks-cost-45-billion-in-2018][www.securitymagazine.com]]: chỉ trong năm 2018 các cuộc tấn công mạng đã làm tổn thất $45 tỉ đô của toàn thế giớ. Ta thấy chi phí tổn hại sẽ tăng gấp 240 lần chỉ trong 7 năm nếu số liệu từ 2 trang trên tương đối đúng
     #+begin_comment
     - Lấy ví dụ ngay trên topo, một doanh nghiệp trung bình thuê 3 cisco router và 5 cisco switching
       | router3640     | 170$*3=510 |
       | cisco catalyst |            |
     #+end_comment
** Snort: 
   - Snort là một bộ chương trình IDS mã nguồn mở, hoạt động dựa trên các rules store ở text files có thể dễ dành edit bằng các text editor.
   - Các rules của snort được nhóm thành các chủ đề khác nhau. Và ngoài ra có thể chia nhỏ ra thành các files khác nhau. Snort có 1 file config chính là snort.conf .
   - Nên đặt snort nói riêng hay IDS/IPS ở vị trí nào trên network:
     - Ngoài tường lửa:
       #+DOWNLOADED: screenshot @ 2020-12-11 01:03:38
       [[file:_assets/2020-12-11_01-03-37_screenshot.png]]
     - Để thực hiện được điều này, edge-router/switch phải có chức năng port-mirroring, tức sẽ copy các packet chạy qua port nối với máy cần bảo vệ (vì máy vận hành snort cũng là một end device, nó phải thông qua một router trung gian để capture packet ) và gửi nó tới IDS đang vận hành snort hoặc các chương trình tương tự. Ưu điểm của cách thiết kế mạng này là ta có thể capture hết tất cả các packet chạy từ external network vào bên trong network cần bảo vệ. Và ta chỉ cần duy nhất 1 máy vận hành IDS -snort. Cisco switch hỗ trợ tính năng SPAN (Switch Port Analyzer) và Cisco Router hỗ trợ tính năng RITE (Router IP Traffic Export) để copy các packet và gửi nó tới máy vận hành IDS, ta gọi tính năng này là port-mirroring
   - Đằng sau hoặc trong tường lửa: Đơn giản là cài đặt snort trực tiếp trên end device - server cần bảo vệ. Cách này thường không ổn với các IDS cồng kềnh, nhưng ở đây snort được coi là một IDS gọn nhẹ, nên ta cá thể cài snort trên mỗi server khác nhau. Ưu điểm là các packet được lọc qua fỉrewall filter trước nên ta có thể testing xem còn mối nguy hiểm nào mà firewall không lọc đuợc không. Ta cũng tốn ít rules hơn trên mỗi snort
       #+DOWNLOADED: screenshot @ 2020-12-11 01:14:15
       [[file:_assets/2020-12-11_01-14-15_screenshot.png]]

** DDos/DoS:
   - Dos ((Distribute) Denial of Service - tấn công từ chối dịch vụ ) chỉ các kiểu tấn công mạng mà ở đó những kẻ tấn công cố gắng khiến cho một máy tính hoặc một hệ thống máy tính không thể hoặt động bình thường và cung cấp dịch vụ cho những người dùng thông thường của nó. 
   - Mục đích: Làm gián đoạn quá trình vận hành của hệ thống                 
   - Mục tiêu: có thể là một network gồm nhiều thiết bị kết nối với nhau, có thể là chỉ là một router vận hành ở layer 3,4 cũng có thể là một webserver ở application level.
   - Đặc điểm :
     - Attacker gửi lớn yêu cầu rác (spam requests) tới đối tượng tấn công, lợi dụng cơ chế mặc định là đối tượng với phản hồi (response ) các yêu cầu này, khi lượng request quá nhiều vượt quá khả năng vận hành của mục tiêu bị tấn công, sẽ dẫn đến việc server (hoặc mạng máy tính) bị quá tải, và cạn kiệt các tài nguyên cần thiết (như băng thông, hoặc số thread tối đa để duy trì kết nối). Nếu đối tượng bị tấn công là server vận hành ứng dụng web (như apache) sẽ dẫn đến người dùng bình thường không truy cập được. Nếu là 1 router hay một switch layer 3 trong hệ thống mạng của 1 công ty, tổ chức. Có thể dẫn đến những việc vận hành không chính xác. Làm chậm được truyền hệ thống. Mở màn cho những kỹ thuật tấn công khác đi tiếp theo.(như DHCP spoofing nếu DHCP server bị tấn công bởi UDP flood)
     - Dos thường cần có sự phối hợp từ rất nhiều máy tính (lên tới hàng nghìn) cùng gửi yêu cầu rác về đối tượng tấn công. Vì tấn công từ 1 máy thường không đạt được hiệu quả. Các máy tính này còn là zombie machine. Do bị nhúng mã độc từ trước bởi kẻ tấn công và các mã độc này sẽ nằm ẩn trong máy. Khi kẻ tấn công phát động từ xa, hàng loạt các máy zombie sẽ cùng gửi request tới mục tiêu. Do đó Dos có 1 cái tên khác là DDoS, nghĩa Distributed DoS.
      
* Kịch bản thực hành:

** Cài đặt snort trên centos:

   - Snort - vốn là một ứng dụng mã nguồn mở, nên thường đa dạng trong cách cài đặt, do các ứng dụng mã nguồn mở thường được dùng ở nhiều môi trường khác nhau, từ nền tảng x86 như GNU/linux tới FreeBSD,OpenBSD,...Window. Thậm chí là các kiến trúc Sparc như Solaris, MacOS-X...
   - Ở đây ta thực hiện cài đặt trên snort:
   - Để nhanh chóng ta sẽ viết một đoạn perl script để tự động hoá quá trình này.
     #+begin_src perl
# install_snort.pl
       use strict;
       use warnings;


       map {system "$_"}(
         "echo update and install epel-release, epel-release la mot repo ho tro cac package nang cao ma snort yeu cau, repo nay rat pho bien va moi centos sysamin deu dung",
         "yum update -y",
         "yum install epel-release -y",
         "echo cai dat snort truc tiep tu trang chu cua snort,"
         "yum install https://www.snort.org/downloads/snort/snort-2.9.17-1.centos8.x86_64.rpm -y",
         "echo mot loi he thong tren centos 8 khien snort khong phat hien file libnet.1, ta giai quyet nhu sau",
         "ln -s /usr/lib64/libdnet.so.1.0.1 /usr/lib64/libdnet.1"
       );
     #+end_src

     Ta có thể dùng normal mode trên snort bình thường
     #+DOWNLOADED: screenshot @ 2020-12-11 02:01:11
     [[file:_assets/2020-12-11_02-01-11_screenshot.png]]
 Tuy nhiên để dùng IDS mode và load được file /etc/snort/snort.conf, ta phải thay đổi snort.conf file
#+DOWNLOADED: screenshot @ 2020-12-11 02:03:48
[[file:_assets/2020-12-11_02-03-48_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-11 02:04:18
[[file:_assets/2020-12-11_02-04-18_screenshot.png]]
- Tiếp tục comment các dòng lệnh không cần thiết đu cho tới khi câu lệnh sau chạy bình thường, output về bug của giai đoạn này rất rõ ràng.
  #+begin_src shell
  snort -c /etc/snort/snort.conf 
  #+end_src

** Dùng snort để phát hiện và ngăn chặn ICMP/Ping flood: 
   - ICMP: (Internet Control Message Protocal) là giao thức được thiết kế để kiểm tra xem đường truyền internet có hoạt động bình thường không. IP A sẽ gửi các message tới ip  B ở các cổng xác định và nếu  B phản hồi lại thì cổng đó sẽ có thể nhận tính hiệu.
   - ICMP vận hành ở layer 3, không phải là một transport protocal, nên không dùng để truyền dữ liệu.
   - ICMP thường được phát ra bởi chương trình ping.
   - Kiểu tấn công DoS dựa trên ICMP lợi dụng cơ chế mỗi tín hiệu ICMP gửi phải được phản hồi nếu cổng đó hoạt động bình thường. Và nếu phải phản hồi quá nhiều tín hiệu cùng một lúc sẽ dẫn đến việc đối tượng bị quá tải.


 - Attacker: Ta dùng nmap từ blackarch attacker tới centos server:
 #+begin_src sh
nmap -A -T4 10.0.0.1
 #+end_src
 #+DOWNLOADED: screenshot @ 2020-12-04 12:22:45
 [[file:_assets/2020-12-04_12-22-45_screenshot.png]]

- Attacker:  thấy có 1 cổng được mở.
- Attacker: dùng lệnh hping gửi tín hiệu ping tới centos server
#+begin_src shell
hping3 -1 -p 80 -i u1000 10.0.0.1
#+end_src
#+begin_example
-1 : gửi icmp, không như ping, hping mặc định là gửi tcp packet
-p : cổng
-i u1000: interval, mặc định 1s/1packet, nếu u1000 ta gửi 100 packet/s
#+end_example

 - Attacker: dùng hping trên cả 3 client cùng lúc chứ không phải 1, tổng tấn công vào centó 

#+DOWNLOADED: screenshot @ 2020-12-04 13:12:25
[[file:_assets/2020-12-04_13-12-25_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-04 13:12:49
[[file:_assets/2020-12-04_13-12-49_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-04 13:13:00
[[file:_assets/2020-12-04_13-13-00_screenshot.png]]



#+begin_src shell
> /dev/null để không show output
#+end_src

#+DOWNLOADED: screenshot @ 2020-12-04 13:16:59
[[file:_assets/2020-12-04_13-16-59_screenshot.png]]
Ta thấy từ 1 máy client ta ping tới centos tốc độ response sẽ chậm hơn rất nhiều.
Hình sau là khi ping bình thường trong tình trạng không bị tấn công

#+DOWNLOADED: screenshot @ 2020-12-04 13:18:34
[[file:_assets/2020-12-04_13-18-34_screenshot.png]]

- Phiá phòng thủ: Dùng snort với /etc/snort/rules/local.rules:
  #+DOWNLOADED: screenshot @ 2020-12-04 13:20:24
 [[file:_assets/2020-12-04_13-20-24_screenshot.png]]

  - Ta chạy snort:

#+begin_src shell
centos > snort -A console  -c /etc/snort/snort.conf -i eth0
#+end_src
#+begin_example
-A console: kích hoạt alert mode và in output ra console
-c : dùng file config, đây còn gọi là snipper mode, nếu không dùng file config, snort mặt định sẽ ghi lại tất cả các packet, và không alert.
-i eth0 : listen trên eth0, tránh trường hợp nhầm với các interface khác (như lo)
#+end_example
 - Và snort báo cho ta output. Đây chỉ là output trong  5s, từ 1 attack machine

#+DOWNLOADED: screenshot @ 2020-12-04 13:28:07
[[file:_assets/2020-12-04_13-28-07_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-04 13:28:50
[[file:_assets/2020-12-04_13-28-50_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-04 13:29:14
[[file:_assets/2020-12-04_13-29-14_screenshot.png]]
- Ta thấy chỉ trong 5s snort đã ghi nhận và báo động hơn 700 packet icmp. So với nếu ta ping thông thường từ 1 client thông thường
  #+DOWNLOADED: screenshot @ 2020-12-04 13:31:43
  [[file:_assets/2020-12-04_13-31-43_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-04 13:31:54
[[file:_assets/2020-12-04_13-31-54_screenshot.png]]

- Với 9s, gấp đôi thời gian snort chỉ ghi nhận 15 packet.

- Từ các kết quả trên, giả sử một attacker điều khiển hàng trăm, hàng nghìn máy zombie cùng tấn công thì hậu quả sẽ dẫn đến server bị mất hoàn toàn khả năng phản hồi.


** TCP SYN flood


#+DOWNLOADED: screenshot @ 2020-12-04 22:31:07
[[file:_assets/2020-12-04_22-31-07_screenshot.png]]

- Trong mọi kết nối TCP (dù có kèm HTTP) hay không đều tuân theo 1 quy tắc
  
  - First, the client sends a SYN packet to the server in order to initiate the connection. Client gửi tcp với syn flag (ta gọi là tắt là syn paket) tới server. Mục đích của packet này là báo cho server biết máy khách muốn tạo lập 1 connection. Syn ở đây là synchronize
  - The server then responds to that initial packet with a SYN/ACK packet, in order to acknowledge the communication. Server sẽ response bằng một tcp packet kèm 2 flag SYN/ACK. Ack ở đây là acknowledge. Để báo cho client biết rằng server sẽ chấp nhận kết nối nếu client tiếp tục. Đồng thời server sẽ bind một socket trên một cổng thuộc nhóm random (từ 49152 tới 65535)
  - Finally, the client returns an ACK packet to acknowledge the receipt of the packet from the server. After completing this sequence of packet sending and receiving, the TCP connection is open and able to send and receive data. Sau cùng, client sẽ gửi tiếp một ack packet khác tới server. Client cũng sẽ cũng mở socket trong 1 cổng random (từ 49152 đến 65535) và thực hiện kết nối
- Ngoài ra, nếu muốn kết thúc một kết nối TCP, client hoặc server sẽ gửi packet với flag FIN+ACK packet với phiá còn lại. Quá trình này gọi là termination conection, là một four-way handshake, giao thức 4 giai đoạn
- Giao thức đợi tín hiệu phản hồi kèm flag ack này giúp cho tcp có tính ổn định và hạn chế tối đa việc mất dữ liệu (reliable) và nhờ đó những giao thức được xây dựng phiá trên nó (như HTTP,FTP) sẽ kế thừa tính này.
- Nhưng cũng vì thế mà cá kỹ thuật tấn công lợi dụng giao thức này ra đời, ở đây, ngay khi server phản hổi client với ACK+SYN packet (ở bước 2), nó sẽ bắt đầu mở 1 socket 1 cổng dù chưa thực hiện kết nối. Ta gọi là half-connection, server sẽ đợi cho client trả lời bằng ACK packet. Nếu client cố tình không trả lời hoăc kéo dài thời gian trả lời. Cổng đang half-open đây sẽ trở nên hao phí. Từ đây nếu attacker cố tình gửi hàng loạt các packet SYN cùng một lúc. Sẽ dẫn đến việc nạn nhân mở hàng loạt các cổng và bị quá tải.
- Lấy ví dụ minh họa bởi hping gửi duy nhất 1 SYN packet tới server
 [[file:_assets/2020-12-04_23-23-18_screenshot.png]]

 - Và server sau khi đợi trả lời không thành công sẽ gửi về tiếp một packet với flag RST. RST là reset, là flag báo về từ server nếu kết 3-way handsake thất bại
  [[file:_assets/2020-12-04_23-22-41_screenshot.png]]

- Ta cũng thấy thời gian của một half-open rất ngắn, đo bằng ms. nhưng chỉ với hàng triệu tcp syn packet cùng được gửi. Đủ để làm quá tải bất kỳ hệ thống nào.


#+begin_src shell
hping -S -p 80 10.0.0.1 -i u100 --rand-source > /dev/null
#+end_src
Ta dùng câu lệnh trên ở cả 3 client blackarch cùng một lúc. Tốc độ gửi là 1000 packet/s. flag "-S" bảo hping gửi packet với syn flag. Nếu không hping mặc định sẽ gửi tcp packet không có flag nào cả và sẽ bị drop ngay lập tức.

Và kết quả nhận đượng khi cố gắng gửi packet ICMP (ping) và TCP syn từ một client thường (với tốc độ 1 packet/s)

#+DOWNLOADED: screenshot @ 2020-12-05 00:04:45
[[file:_assets/2020-12-05_00-04-45_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-05 00:05:11
[[file:_assets/2020-12-05_00-05-11_screenshot.png]]

- Và đây là khi ping nếu server không bị tấn công
  #+DOWNLOADED: screenshot @ 2020-12-05 00:06:00
  [[file:_assets/2020-12-05_00-06-00_screenshot.png]]


- Từ phiá phòng thủ: centos ta dùng snort với rules
  #+begin_example
  alert tcp !$HOME_NET any -> $HOME_NET 80 (flags:S;msg:"alert!!!! Some script kiddy try to tcp syn flood your on port 80."; sid:1000002)
  #+end_example

#+DOWNLOADED: screenshot @ 2020-12-05 00:22:37
[[file:_assets/2020-12-05_00-22-37_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-05 00:23:02
[[file:_assets/2020-12-05_00-23-02_screenshot.png]]

- Cách phòng thủ:????



** Application layer DOS - HTTP flood - slow-low attack:

- Cũng như TCP là một giao thức được xây dựng như một lớp abstraction phiá trên IP, HTTP là một giao thức được xây dựng ngay trên nền tảng của các giao thức thuộc các layer phiá dướt của OSI model. HTTP là hypertext transfer protocol, dùng để vận chuyển các dữ liệu dưới dạng nhìn thấy được bởi người dùng thông thường trong môi trường internet. HTTP có thể được xây trên nền TCP hoặc UDP, thuờng là TCP để thừa kế tính đảm bảo của nó. HTTP kết hợp với giao thức bảo mật SSL ta gọi là HTTPS.

  - Ta chạy một apache server trên centos và truy cập cổng 80 từ client với w3m:
    #+begin_src shell
    root@centos-server /e/httpd# httpd
    root@client /# w3m 10.0.0.1
    #+end_src
- Nội dung trên websever cổng 80 của cenos server 
#+DOWNLOADED: screenshot @ 2020-12-05 00:33:14
[[file:_assets/2020-12-05_00-33-14_screenshot.png]]

- Dùng wireshark để phân tích kết nối http này, ta thấy có tới hơn 10 packet được trao đổi qua lại nhưng chỉ có 2 dòng là HTTP, còn lại đều là TCP (SYN,ACK,FIN), nó cho thấy HTTP chỉ là một protocal phụ thuộc vào protocol ở layer thấp hơn.
- Diễn giải: client sẽ gửi TCP ack để bắt đầu 3-way-handshake như ta đã giải thích ở ví dụ liền trước. Sau khi đảm bảo kết nối được establish. HTTP request sẽ được gửi đi. Ta nhận diện bằng HTTP header với dòng GET là flag của HTTP, và 1.0 là version của HTTP. Sau đó giữa 2 endnode sẽ bắt có 1 quá trình trao đổi TCP ack và psh. Psh là push flag báo rằng data phải được chuyển ngay tới phiá bên kia, vì data ở HTTP thuờng có dung lượng rất lớn và phải được chia nhỏ ra trước khi gửi, flag này nhằm thúc đẩy nhanh quá trình gửi data. Ở bài thuyết trình này không đi sâu vào. Server reponsse với status 443 vì ta không đặt bất kỳ trang web nào trên trang chủ. Ngay sau khi respone. Vì thấy rằng không cần thiết để duy trì kết nối nữa, máy chủ chủ động gửi tcp fin để bắt đầu quá trình kết thúc TCP connection.
#+DOWNLOADED: screenshot @ 2020-12-05 00:42:28
[[file:_assets/2020-12-05_00-42-28_screenshot.png]]

- Như ta đã thấy, HTTP tốn rất ít nhất gấp 2 lần số giai đoạn so với 1 TCP thông thưòng và thậm chí nếu thông qua HTTPS ta còn tốn thêm 2 lần nữa. Do SSL là 3-way-handshake protocal. Và dĩ nhiên bản thân mỗi kết nối HTTP có thể duy trì rất lâu(như streaming,voip). Do đó kiểu tấn công HTTP/HTTPS flood thường gây tổn hại nặng nề hơn so với các kiểu nêu trước đây. Cách vận hành của kiểu tấn công này cũng gần tương tự, lợi dụng cơ chế bảo toàn dữ liệu handshake qua nhiều giai đoạn, attacker hoặc cố gắng duy trì quá trình half-open càng lâu càng tốt, hoặc ngược lại duy trì quá trình kết nối establist connection càng lâu càng tốt cũng như gửi càng nhiêu kết nối . Từ đó làm máy tính nạn nhân cạn kiệt khả năng để response các kết nối thông thường.
  - Ta không dùng hping nữa vì công cụ này không hỗ trợ giao thức http.
  - Dùng slowloris, công cụ này hứa hẹn  sẽ giữ kết nối các kết nối http của nó càng lâu càng tốt.
  - Ở ví dụ này chúng ta khai thác hướng tiếp cận mới, một kiểu dos được gọi là slow and low attack, vì thay vì làm chậm
- Ta thử nghiệm slowloris với 1 kết nối
  #+begin_src perl
  root@blackarch-3 /# slowloris-py  -s 1 -p 80 10.0.0.1 --sleeptime 30
  #+end_src
  #+begin_example
  -s : số lượng socket, ở đây ta chỉ đặt 1
  -p 80 : port 80
  --sleeptime 30. Mỗi kết nối sẽ được restart sau 30s
  #+end_example
 - Từ wireshark, ta thấy slowlorish thành công trong việc giữ kết nối này tới 20s tới khi bị server chủ động huỷ kết nối 
#+DOWNLOADED: screenshot @ 2020-12-05 01:40:37
[[file:_assets/2020-12-05_01-40-37_screenshot.png]]

- Xét ví dụ sau:
  - Chạy apache server trên centos-server ở cổng 80
  - Ta thấy nếu dùng w3m- web browser trên cli - để kết nối tới 10.0.0.1:80 trong điều kiện bình thường
    #+DOWNLOADED: screenshot @ 2020-12-09 01:08:21
    [[file:_assets/2020-12-09_01-08-21_screenshot.png]]

- Tiếp theo ta set up snort với rule như sau trên centos server
- Đây là snort rules ta dùng để phát hiện http request tới cổng 80    
#+begin_src shell
alert tcp !$HOME_NET any -> $HOME_NET 80 (msg:"Those kids attack by http!!!";content:"HTTP"; sid: 1000003; rev:1)
#+end_src
- Dùng câu lệnh để chạy snort:
#+begin_src shell
centos-server #  snort -A console -c /etc/snort/snort.conf
#+end_src
- Tiếp theo ta dùng slowloris.py (slowloris có 2 phiên bản viết bằng perl và python) với câu lệnh như sau trên cả 2 máy attacker. 
#+begin_src cperl
root@blackarch-2 /# slowloris-py -p 80  --sleeptime 10 10.0.0.1
root@blackarch-3 /# slowloris-py -p 80  --sleeptime 10 10.0.0.1
root@blackarch-1 /# slowloris-py -p 80  --sleeptime 10 10.0.0.1
#+end_src
- Ta thấy slowloris sẽ tạo ra các kết nối trên các socket khác nhay và cố gắng duy trì các kết nối này càng lâu càng tốt với keep-alive header

#+DOWNLOADED: screenshot @ 2020-12-08 11:35:46
[[file:_assets/2020-12-08_11-35-46_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-08 11:35:59
[[file:_assets/2020-12-08_11-35-59_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-08 11:44:15
[[file:_assets/2020-12-08_11-44-15_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-08 11:44:25
[[file:_assets/2020-12-08_11-44-25_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-08 11:44:38
[[file:_assets/2020-12-08_11-44-38_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-08 11:45:44
[[file:_assets/2020-12-08_11-45-44_screenshot.png]]


#+begin_comment
Advanture attack -> write script that auto attack with http request. USe burpsuite or wireshark to capture
#+end_comment

#+begin_comment
- NTP amplication dos attack
- UDP-DNS flood attack
- DNS amplication attack
#+end_comment

#+begin_src octave
1000*2
#+end_src

#+RESULTS:
: 2000

* Footnotes

[fn:1] https://www.intechopen.com/books/computer-and-network-security/anomaly-based-intrusion-detection-system

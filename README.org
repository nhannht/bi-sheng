#+TITLE: Snort-báo-cáo
* Topo 1: 
#+DOWNLOADED: screenshot @ 2020-12-04 13:43:14
[[file:_assets/2020-12-04_13-43-14_screenshot.png]]


 #+begin_comment
** Project: Mile stone:  [3/14]                                    :noexport:
*** Use dvwa 
**** Dvma -> iptables, snort
**** TODO Snort in general
**** DONE ICMP reflection -> hping
**** TODO ICMP packet injection -> ping of death
***** Use proxy, iptables, firewall to mitigate
***** TODO Scripting instead of use tool
**** DONE TCP bandwhich-consumming reflection base -> hping
**** DONE HTTP slow and low -> slowloris
**** TODO HTTP bandwhich consuming
**** TODO UDP bandwhich-consuming -> UDP flood
**** TODO NTP amplication
**** TODO DNS flood -reflection
**** TODO DNS amplication
**** Smurt attack
**** Fraggle attack
**** LOIC attack
**** HOIC attack
**** SNMP amplication
**** SSDP amplication
**** TODO Voip in general
**** TODO Aterisk in general
**** Ping of death
**** TODO same subnet asterisk deploy
**** TODO over internet asterisk deply
**** snort sam
**** Docker built
**** Preprocessor
**** snort plug
 # *** DVWA
**** None DOs attack:
***** XSS
***** SQL injection
  #+end_comment


 
      - 
** Lời mở đầu:
*** Tầm quan trọng của IDS/IPS
*** Sự nguy hiểm của tấn công DoS
*** Tóm tắt nội dung:
   - Bài tiểu luận cho môn mạng máy tính nâng cao
   - Nội dung:
     - tìm hiểu về IDS/IPS (hệ thống phát hiện/phòng chống nỗ lực tấn công từ bên ngoài vào mạng lưới).
     - tìm hiểu về snort. Framework điểu hình về IDS/IPS
     - tìm hiểu về DoS/DDoS attack
     - Xây dựng hệ thống IDS/IPS với snort là trung tâm phòng thủ và DDos là kỹ thuật tấn công chính. GNS3 là môi trường thực nghiệm
*** Tóm tắt hướng nghiên cứu:
**** Về lý thuyết: Snort sở hữu 1 hệ thống tài liệu phong phú và đầy đủ về nội dung lẫn ví dụ, nhóm chủ yếu sẽ tổng hợp lại ở các phần: 
***** Cách cài đặt
***** Cách set up các rules cơ bản để đối phó với từng kiểu tấn công DDoS
***** Cách sử dụng các extension mở rộng
**** Về DoS, hướng tân công này rất đa dạng, nhóm phân loại theo 2 hướng:
***** Dựa trên OSI model:
****** Layer 3 (Internet Protocol layer):
       -ping flood, Ping of Death
****** Layer 4 (Transport layer): -
       udp flood, tcp flood,....
****** Layer 5-6-7 (Application Layers):
       - dùng https
***** Dựa trên hướng tân công:
****** Volumetric Attack:
       - tạo ra một lượng lớn traffic để làm tràn bandwidth của hệ thống nạn nhân: TCP/UPD flood, NTP amplication, DNS amplication
****** Protocol Base Attack:
       - dựa trên cách hoạt động của các giao thức ở layer 3 và layer 4.   Sync Flood, Ping of Death, DNS amplication, ...
****** Application Attack:
       - hướng khai thác này phụ thuộc vào loại application. Mỗi chương trình sẽ có các nhược điểm riêng của nó. Như Apache sẽ bị tổn thương theo mặc định  (nếu không được điều chỉnh ) bởi HTTP low-and-slow attack, trong khi Nginx hay Nodejs sẽ không bị ảnh hưởng
**** Về thực nghiệm:
     - thực hiện các lab trên gns3,
     - các máy ảo dùng docker container: 1 Centos-server - server nạn nhân, 5 blackarch - botnet được điều khiển bởi attacker, 1 alpine linux - máy client thông thường 
     - Các thiết bị khác thuộc network: Cisco IOS router, 4 open-switch  của GNS3 team, 4 "máy ảo" mini do VPCS (không thật sự là hệ điều hành, chỉ có các tính năng như ping hay dhcp request) - đóng vai trò như client thông thường .
     - Nmap, Wireshark.
     - Mô phỏng các hướng DOS cụ thể: ping flood, ping of death, tcp syn-ack flood, udp flood, dns amplication, slow-and-slow http attack, http flood
     - Ngoài ra còn thêm vài kỹ thuật không phải DoS: sql injection,...
     - Mục tiêu: thể hiện được được truyền của đối tượng bị suy giảm mạnh, hoặc thậm chí đối tượng bị crash hoặc không truy cập được(web server). Thể hiện sự khác biệt về lượng traffic ở môi trường khoẻ mạnh và môi trường bị DDoS. Dùng Snort để phát hiện và log thông tin về các kiểu tấn công này. Nêu ra được giải pháp phòng thủ: có thể dùng snort extension, hoặc iptables, hoặc điều chỉnh trên chính apache2, trên các router.
    
** Cơ sở lý thuyết:

*** IDS/IPS là gì:
    - Instrusion detection (hệ thống phát hiện thâm nhập) là một bộ các kỹ thuật và phương pháp được thiết kế để phát hiện những hành vi có thể gây nguy hại tới hệ thống (theo nghĩa toàn bộ hệ thống hoặc từng thành phần riêng lẻ). IDS rới vào 2 nhóm chính: Signature-based IDS (dựa trên chữ ký) và anomaly detection IDS (dựa trên sự bất thường ).
    - Những đối tượng xâm nhậm có chữ ký (như virus máy tính), có thể bị phát hiện bởi các phần mềm. IDS dựa trên chữ ký số hoạt động dưa trên việc đối chiếu nội dung của đối tượng với các chữ ký được lưu lại trên các database về malware hoặc các rule được người vận hành IDS thiết lập bằng tay -> Nếu phát hiện sẽ báo động
    - Ngược lại IDS based anamoly dựa trên các mô hình máy học để phát hiện các mối nguy hiểm. Phần này sẽ không đi sâu vào trong bài tiểu luận này
    - Snort thuộc nhóm 1: tức rules-signature IDS, tuy nhiên một số extension của snort hỗ trợ nhóm 2.
     
      - Theo trang [[https://cybersecurityventures.com/hackerpocalypse-cybercrime-report-2016/][cypersecurityventure.com]]: tổn hại do tội phạm mạng gây ra sẽ làm tổn thất 10,5 tỉ tỉ đô của thế giới vào năm 2025
      - Theo trang [[https://www.securitymagazine.com/articles/90493-cyber-attacks-cost-45-billion-in-2018][www.securitymagazine.com]]: chỉ trong năm 2018 các cuộc tấn công mạng đã làm tổn thất $45 tỉ đô của toàn thế giớ. Ta thấy chi phí tổn hại sẽ tăng gấp 240 lần chỉ trong 7 năm nếu số liệu từ 2 trang trên tương đối đúng
      #+begin_comment
      - Lấy ví dụ ngay trên topo, một doanh nghiệp trung bình thuê 3 cisco router và 5 cisco switching
        | router3640     | 170$*3=510 |
        | cisco catalyst |            |
      #+end_comment
*** Snort: 
    - Snort là một bộ chương trình IDS mã nguồn mở, hoạt động dựa trên các rules store ở text files có thể dễ dành edit bằng các text editor.
    - Các rules của snort được nhóm thành các chủ đề khác nhau. Và ngoài ra có thể chia nhỏ ra thành các files khác nhau. Snort có 1 file config chính là snort.conf .
    - Nên đặt snort nói riêng hay IDS/IPS ở vị trí nào trên network:
      - Ngoài tường lửa:
        #+DOWNLOADED: screenshot @ 2020-12-11 01:03:38
        [[file:_assets/2020-12-11_01-03-37_screenshot.png]]
      - Để thực hiện được điều này, edge-router/switch phải có chức năng port-mirroring, tức sẽ copy các packet chạy qua port nối với máy cần bảo vệ (vì máy vận hành snort cũng là một end device, nó phải thông qua một router trung gian để capture packet ) và gửi nó tới IDS đang vận hành snort hoặc các chương trình tương tự. Ưu điểm của cách thiết kế mạng này là ta có thể capture hết tất cả các packet chạy từ external network vào bên trong network cần bảo vệ. Và ta chỉ cần duy nhất 1 máy vận hành IDS -snort. Cisco switch hỗ trợ tính năng SPAN (Switch Port Analyzer) và Cisco Router hỗ trợ tính năng RITE (Router IP Traffic Export) để copy các packet và gửi nó tới máy vận hành IDS, ta gọi tính năng này là port-mirroring
    - Đằng sau hoặc trong tường lửa: Đơn giản là cài đặt snort trực tiếp trên end device - server cần bảo vệ. Cách này thường không ổn với các IDS cồng kềnh, nhưng ở đây snort được coi là một IDS gọn nhẹ, nên ta cá thể cài snort trên mỗi server khác nhau. Ưu điểm là các packet được lọc qua fỉrewall filter trước nên ta có thể testing xem còn mối nguy hiểm nào mà firewall không lọc đuợc không. Ta cũng tốn ít rules hơn trên mỗi snort
        #+DOWNLOADED: screenshot @ 2020-12-11 01:14:15
        [[file:_assets/2020-12-11_01-14-15_screenshot.png]]

*** DDos/DoS:
    - Dos ((Distribute) Denial of Service - tấn công từ chối dịch vụ ) chỉ các kiểu tấn công mạng mà ở đó những kẻ tấn công cố gắng khiến cho một máy tính hoặc một hệ thống máy tính không thể hoặt động bình thường và cung cấp dịch vụ cho những người dùng thông thường của nó. 
    - Mục đích: Làm gián đoạn quá trình vận hành của hệ thống                 
    - Mục tiêu: có thể là một network gồm nhiều thiết bị kết nối với nhau, có thể là chỉ là một router vận hành ở layer 3,4 cũng có thể là một webserver ở application level.
    - Đặc điểm :
      - Attacker gửi lớn yêu cầu rác (spam requests) tới đối tượng tấn công, lợi dụng cơ chế mặc định là đối tượng với phản hồi (response ) các yêu cầu này, khi lượng request quá nhiều vượt quá khả năng vận hành của mục tiêu bị tấn công, sẽ dẫn đến việc server (hoặc mạng máy tính) bị quá tải, và cạn kiệt các tài nguyên cần thiết (như băng thông, hoặc số thread tối đa để duy trì kết nối). Nếu đối tượng bị tấn công là server vận hành ứng dụng web (như apache) sẽ dẫn đến người dùng bình thường không truy cập được. Nếu là 1 router hay một switch layer 3 trong hệ thống mạng của 1 công ty, tổ chức. Có thể dẫn đến những việc vận hành không chính xác. Làm chậm được truyền hệ thống. Mở màn cho những kỹ thuật tấn công khác đi tiếp theo.(như DHCP spoofing nếu DHCP server bị tấn công bởi UDP flood)
      - Dos thường cần có sự phối hợp từ rất nhiều máy tính (lên tới hàng nghìn) cùng gửi yêu cầu rác về đối tượng tấn công. Vì tấn công từ 1 máy thường không đạt được hiệu quả. Các máy tính này còn là zombie machine. Do bị nhúng mã độc từ trước bởi kẻ tấn công và các mã độc này sẽ nằm ẩn trong máy. Khi kẻ tấn công phát động từ xa, hàng loạt các máy zombie sẽ cùng gửi request tới mục tiêu. Do đó Dos có 1 cái tên khác là DDoS, nghĩa Distributed DoS.
      
*** IPtables:         

    - Iptables là command line tool dùng để chỉnh firewall của linux kernel, thuộc [[https://en.wikipedia.org/wiki/Netfilter][Netfilter Project]], iptables là có ưu điểm là tuổi đời lâu, mã nguồn mở, vẫn tiếp tục được phát triển ở thời điểm hiện tại, chức năng rất phong phú, hộ trợ cross platform, vì là firewall ở tầng kernel nên rất mạnh mẽ ( và cũng rất nguy hiểm nếu config sai).
    - Sơ lược về cơ chế hoạt động: Iptables xoay quanh 3 khái niệm chính là chain, table và rules.
      - Chain là khái niệm thường gặp nhất, in ra bằng câu lệnh
      #+begin_src shell
iptables -L
      #+end_src

#+DOWNLOADED: screenshot @ 2020-12-19 02:29:59
    - Tables là đơn vị lớn hơn chains, bao gồm raw,filter,nat,mangle,security. THực tế khi ta dùng ~iptables -L,~ ta mặc định in ra các chain trong table ~filter~
    - Rules: là tổ hợp giữa chain và các option. Chain, về bản chất, chỉ là một cái tên, một alias để người dùng dễ tổ chức các rules, tables filter có 3 default chain là INPUT,OUTPUT,FORWARD, tự các cụm từ này sẽ không có ý nghĩa nếu nó không có các options đi kèm với nó

    - Mặc định 1 linux mới cài đặt sẽ đi kèm 3 rules sau:
      #+begin_src shell
iptables -nvL

Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
      #+end_src
    - Ta thấy policy là trong những option đi kèm với cả 3 chain trên, policy là một option được áp vào một chain mặc định và chỉ có 2 giá trị là DROP/ACCEPT.
    - Ta áp policy và một rule bằng flag -P (~iptables -P <chain> <rules>~) và ngược lại nếu dùng option flag -S ta sẽ in ra rules của 1 chain
    - 
    #+begin_src shell
iptables -S INPUT
    #+end_src
#+DOWNLOADED: screenshot @ 2020-12-19 02:42:22
[[file:_assets/2020-12-19_02-42-22_screenshot.png]]

    - Bài này không đi sâu vào iptables, nên chỉ nói sơ lược như thế, một số ví dụ về iptables
      #+begin_src shell
        #cho phép kết nối in out của loop back interface
        iptables -A INPUT -i lo -j ACCEPT
        iptables -A OUTPUT -o lo -j ACCEPT
        # -A là option/flag append, tức điền rules vào một chain
        # -i -o là in/out interface
        # -j là jump, jump tới một policy (thường là ACCEPT/DROP/REJECT)
        # Chặn packet từ 1 ip nguồn, -s là source ip
        iptables -A INPUT -s 192.168.252.10 -j DROP
      #+end_src
*** Về Mod-security:
#+begin_comment
Understanding ModSecurity
ModSecurity is a hybrid web application firewall that relies on the host web server for some of the work. The only supported web server at the moment is Apache 2.x, but it is possible, in principle, to integrate ModSecurity with any other web server that provides sufficient
integration APIs.
Apache does for ModSecurity what it does for all other modules—it handles the infrastruc- ture tasks:
1. Decrypts SSL
2. Breaks up the inbound connection stream into HTTP requests
3. Partially parses HTTP requests
#+end_comment
- ModSecurity là một hydrid web-application firewall phụ thuộc vào host là máy chủ mà nó bảo vệ để cùng hoạt động. Nó chỉ support Apache, tuy nhiên có hỗ trợ API để kết hợp với các web khác
#+begin_comment
Understanding ModSecurity
Apache does for ModSecurity what it does for all other modules—it handles the infrastruc- ture tasks:
1. Decrypts SSL
2. Breaks up the inbound connection stream into HTTP requests
3. Partially parses HTTP requests
Request line and headers are NUL-terminated
This is normally not a problem, because what Apache doesn’t see cannot harm any module or application. In some very rare cases, however, the purpose of the NUL- byte evasion is to hide things and this Apache behavior only helps with the hiding. Request header transformation Apache will canonicalize request headers, combining multiple headers that use the same name and collapsing those that span two or more lines. The transformation may make it difficult to detect subtle signs of evasion, but in practice this hasn’t been a problem yet.
#+end_comment
- Nó phải phụ thuộc vào Apache để phân giải SSL, HTTP request nên gọi là hydrid firewall
#+begin_comment
Quick request handling Apache will handle some requests quickly, leaving ModSecurity unable to do any- thing but notice them in the logging phase. Invalid HTTP requests, in particular, will be rejected by Apache without ModSecurity having a say. No access to some response headers Because of the way Apache works, the Server and Date response headers are invisible to ModSecurity; they cannot be inspected or logged.
#+end_comment
- 4 chức năng chính của modsec:
  - Parsing: phân tích các gói data để áp rules lên
  - buffering: nghĩa là gói các request và response lại nhằm đảm bảo sự hoàn chính của mỗi request/response khi phân tích. Dĩ nhiên sẽ làm tốn RAM hơn
  - Logging: Log full transaction
  - Rule Engine: cung cấp hệ thống rules hoàn chỉnh và áp đặt rule đó lên mỗi transaction
    
#+begin_comment
What Rules Look Like
Everything in ModSecurity revolves around two things: configuration and rules. The configuration tells ModSecurity how to process the data it sees; the rules decide what to do with the processed data. Although it is too early to go into how the rules work, I will show you a quick example here just to give you an idea what they look like.
For example:
SecRule ARGS "<script>" log,deny,status:404
Even without further assistance, you can probably recognize the part in the rule that specifies what we wish to look for in input data (<script>). Similarly, you will easily figure out what will happen if we do find the desired pattern (log,deny,status:404). Things will become more clear if I tell you about the general rule syntax, which is the following:
SecRule VARIABLES OPERATOR ACTIONS
The three parts have the following meanings:
1. The VARIABLES part tells ModSecurity where to look. The ARGS variable, used in the
example, means all request parameters.
2. The OPERATOR part tells ModSecurity how to look. In the example, we have a regular
expression pattern, which will be matched against ARGS.
3. The ACTIONS part tells ModSecurity what to do on a match. The rule in the example gives three instructions: log problem, deny transaction and use the status 404 for the denial (status:404).
I hope you are not dissapointed with the simplicity of this first rule. I promise you that by combining the various facilities offered by ModSecurity, you will be able to write very useful rules that implement complex logic where necessary.
#+end_comment
- Rules và transaction: ở modsec có khái niệm transaction, chỉ một giai đoạn hoàn chỉnh từ lúc request đi qua firewall vào host và response từ host -> ra ngoài firewall. Gồm 5 phase:
  - Request Header(1) -> Request Body (2) -> Response Headers (3) -> Response Body (4) -> logging (5). Cơ chế hoạt động là áp rules lên trước khi mod thực hiện phân tích thành phần tương ứng với tên phase. Nghĩa là rules áp lên phase 1 sẽ thực thi trước cả khi parse header request và rules ở phase 5 thực thi sau khi parse xong response body và trước khi log
    - Mỗi rules luôn có dạng
        #+begin_example
    SecRule Variables operator/filter actions
        #+end_example
    - Theo [[https://coreruleset.org/docs/][https://coreruleset.org/docs/]], có tổng cổng 105 variable, 36 operator,35 transsformation,47 actions trong ModSec. nghĩa là có ít nhất
        #+begin_src perl
    105*36*35*47

        #+end_src

        #+RESULTS:
        : 6218100 minimum rules combination, chưa tính việc một rule có thể chain với rule khác, hay khái niệm variable trong modsec thực chất mặc định là một collection, nghĩa là có thể chia nhỏ ra nhiều variable nhỏ hơn

    - Tuy nhiên thực tế, chỉ có một số rule thông dụng.
    - Với sự phong phú về rules như thế , modsec là firewall mạnh mẽ nhất của Apache ở phương diện web application.

    - Bài viết này, vì giới hạn thời gian (1 tháng) và nhóm còn bận nhiều việc khác. Nên không xoáy sâu vào những phần phức tạp hơn như logging, hay core-rules sec, hay Lua script...

    - Data persisten: ngoài cơ chế chia theo transition/phase, modsec còn quản lý dữ liệu theo data persisten mechanism, nghĩa là mỗi collection sẽ được lưu lại với một khoảng timeout nhất định, theo mặc định là 3600s. Nói cho dễ hiệu, ta có collection IP, một collection mặc định từ Apache 2.5x trở lên, nó lưu lại mọi địa chỉ IP qua lại giữa modsec firewall, nếu chỉ hoạt động theo transition/phase, thì mỗi ip sẽ bị xoá đi ngay sau khi nó đi vào/ra khỏi firewall, tuy nhiên cơ chế dp sẽ lưu lại mỗi địa chỉ ip trong 3600s. Cơ chế này được dùng rất nhiều, ví dụ ta dùng collection IP để chống lại DOS, bằng cách tạo một variable IP.counter và đếm số lần mỗi IP xuất hiện nhằm allow,block. 

    - Một số ví dụ:
#+begin_src apache
       # block mọi request từ 10.0.0.1
       SecRule REMOTE_ADDR "streq 10.0.0.1" "id:1000, phase:1, block,log"
     # Dùng perl regrex, filter 192.168.1.{1-5}, không log
       SecRule REMOTE_ADDR "@rx ^192\.168\.1\.(1|5|10)$" \
       phase:1,nolog,allow
   # SEcAction là secrule đặc biệt không cần phải có variable và filter, nghĩa là sẽ thực thi không điều kiện các action sau.
       #Ở đây là khởi tạo, tăng biến IP.couter lên 1 đơn vị. UPDATE_RATE là built-in variable cho collection IP, số request mỗi giây. Nghĩa là ta block mọi ip mà gửi hơn 5 requesst mỗi giây
       SecAction phase:1,nolog,pass,setvar:IP.counter=+1
       SecRule IP:UPDATE_RATE "@gt 5" \
   "phase:1,block,msg:IP này gửi hơn 5 request mỗi giây: %{IP.UPDATE_RATE},có thể dos"
#+end_src
#+begin_example
- Modsec là firewall ở application level, không dùng để chặn DOS tư ICMP, TCP, UDP... 
#+end_example
** Kịch bản thực hành:


*** Cài đặt snort trên centos:

    - Snort - vốn là một ứng dụng mã nguồn mở, nên thường đa dạng trong cách cài đặt, do các ứng dụng mã nguồn mở thường được dùng ở nhiều môi trường khác nhau, từ nền tảng x86 như GNU/linux tới FreeBSD,OpenBSD,...Window. Thậm chí là các kiến trúc Sparc như Solaris, MacOS-X...
    - Ở đây ta thực hiện cài đặt trên snort:
    - Để nhanh chóng ta sẽ viết một đoạn perl script để tự động hoá quá trình này. 
    #+begin_src perl
      # install_snort.pl
      use strict;
      use warnings;


      map {system "$_"}(
          "echo update and install epel-release, epel-release la mot repo ho tro cac package nang cao ma snort yeu cau, repo nay rat pho bien va moi centos sysamin deu dung",
          "yum update -y",
          "yum install epel-release -y",
          "echo cai dat snort truc tiep tu trang chu cua snort,"
          "yum install https://www.snort.org/downloads/snort/snort-2.9.17-1.centos8.x86_64.rpm -y",
          "echo mot loi he thong tren centos 8 khien snort khong phat hien file libnet.1, ta giai quyet nhu sau",
          "ln -s /usr/lib64/libdnet.so.1.0.1 /usr/lib64/libdnet.1"
      );

    #+end_src


   
  #+begin_comment
        # open my $write , " >" , "/etc/snort/snort.conf";
        # while (<$write>){
        #     s/^(dynamic.*$)/#$1/;
  #+end_comment


      - Ta có thể dùng normal mode trên snort bình thường

      #+DOWNLOADED: screenshot @ 2020-12-11 02:01:11
      [[file:_assets/2020-12-11_02-01-11_screenshot.png]]
  Tuy nhiên để dùng IDS mode và load được file /etc/snort/snort.conf, ta phải thay đổi snort.conf file
 #+DOWNLOADED: screenshot @ 2020-12-11 02:03:48
 [[file:_assets/2020-12-11_02-03-48_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-11 02:04:18
 [[file:_assets/2020-12-11_02-04-18_screenshot.png]]
 - Tiếp tục comment các dòng lệnh không cần thiết đu cho tới khi câu lệnh sau chạy bình thường, output về bug của giai đoạn này rất rõ ràng.
   #+begin_src shell
   snort -c /etc/snort/snort.conf 
   #+end_src

   - Các mode và command-line trong snort:

    
     | -A | bật alert mode                                        |
     | -b | log packet ở tcpdump format                           |
     | -c | sử dụng config file                                   |
     | -D | chạy snort ở deamon, background mode                  |
     | -i | chạy snort trên interface                             |
     | -l | log snort trên file                                   |
     | -M | danh sách host MS window snort sẽ báo về nếu có alert |
     | -T | debug snort.conf                                      |





***  ICMP/Ping flood: 
    - ICMP: (Internet Control Message Protocal) là giao thức được thiết kế để kiểm tra xem đường truyền internet có hoạt động bình thường không. IP A sẽ gửi các message tới ip  B ở các cổng xác định và nếu  B phản hồi lại thì cổng đó sẽ có thể nhận tính hiệu.
    - ICMP vận hành ở layer 3, không phải là một transport protocal, nên không dùng để truyền dữ liệu.
    - ICMP thường được phát ra bởi chương trình ping.
    - Kiểu tấn công DoS dựa trên ICMP lợi dụng cơ chế mỗi tín hiệu ICMP gửi phải được phản hồi nếu cổng đó hoạt động bình thường. Và nếu phải phản hồi quá nhiều tín hiệu cùng một lúc sẽ dẫn đến việc đối tượng bị quá tải.


  - Attacker: Ta dùng nmap từ blackarch attacker tới centos server:
  #+begin_src shell
 nmap -A -T4 10.0.0.1
  #+end_src
  #+DOWNLOADED: screenshot @ 2020-12-04 12:22:45
  [[file:_assets/2020-12-04_12-22-45_screenshot.png]]

 - Attacker:  thấy có 1 cổng được mở.
 - Attacker: dùng lệnh hping gửi tín hiệu ping tới centos server
 #+begin_src shell
 hping3 -1 -p 80 -i u1000 10.0.0.1
 #+end_src
 #+begin_example
 -1 : gửi icmp, không như ping, hping mặc định là gửi tcp packet
 -p : cổng
 -i u1000: interval, mặc định 1s/1packet, nếu u1000 ta gửi 100 packet/s
 #+end_example

  - Attacker: dùng hping trên cả 3 client cùng lúc chứ không phải 1, tổng tấn công vào centó 

 #+DOWNLOADED: screenshot @ 2020-12-04 13:12:25
 [[file:_assets/2020-12-04_13-12-25_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-04 13:12:49
 [[file:_assets/2020-12-04_13-12-49_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-04 13:13:00
 [[file:_assets/2020-12-04_13-13-00_screenshot.png]]



 #+begin_src shell
 > /dev/null để không show output
 #+end_src

 #+DOWNLOADED: screenshot @ 2020-12-04 13:16:59
 [[file:_assets/2020-12-04_13-16-59_screenshot.png]]
 Ta thấy từ 1 máy client ta ping tới centos tốc độ response sẽ chậm hơn rất nhiều.
 Hình sau là khi ping bình thường trong tình trạng không bị tấn công

 #+DOWNLOADED: screenshot @ 2020-12-04 13:18:34
 [[file:_assets/2020-12-04_13-18-34_screenshot.png]]

 - Phiá phòng thủ: Dùng snort với /etc/snort/rules/local.rules:
   #+begin_src snort
     alert icmp !$HOME_NET any -> $HOME_NET 80 (msg:"icmp flood attack to port 80!!!"; threshold : type threshold,track by_dst, count 200, seconds 60; sid:1000001;rev:1)

   #+end_src
   #+DOWNLOADED: screenshot @ 2020-12-04 13:20:24
  [[file:_assets/2020-12-04_13-20-24_screenshot.png]]

   - Ta chạy snort:

 #+begin_src shell
 centos > snort -A console  -c /etc/snort/snort.conf -i eth0
 #+end_src
 #+begin_example
 -A console: kích hoạt alert mode và in output ra console
 -c : dùng file config, đây còn gọi là snipper mode, nếu không dùng file config, snort mặt định sẽ ghi lại tất cả các packet, và không alert.
 -i eth0 : listen trên eth0, tránh trường hợp nhầm với các interface khác (như lo)
 #+end_example
  - Và snort báo cho ta output. Đây chỉ là output trong  5s, từ 1 attack machine

 #+DOWNLOADED: screenshot @ 2020-12-04 13:28:07
 [[file:_assets/2020-12-04_13-28-07_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-04 13:28:50
 [[file:_assets/2020-12-04_13-28-50_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-04 13:29:14
 [[file:_assets/2020-12-04_13-29-14_screenshot.png]]
 - Ta thấy chỉ trong 5s snort đã ghi nhận và báo động hơn 700 packet icmp. So với nếu ta ping thông thường từ 1 client thông thường
   #+DOWNLOADED: screenshot @ 2020-12-04 13:31:43
   [[file:_assets/2020-12-04_13-31-43_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-04 13:31:54
 [[file:_assets/2020-12-04_13-31-54_screenshot.png]]

 - Với 9s, gấp đôi thời gian snort chỉ ghi nhận 15 packet.

 - Từ các kết quả trên, giả sử một attacker điều khiển hàng trăm, hàng nghìn máy zombie cùng tấn công thì hậu quả sẽ dẫn đến server bị mất hoàn toàn khả năng phản hồi.

**** IPtables:
     #+begin_src fish
              # tạo một chain mới
                     iptables --new-chain RATE-LIMIT
              # lọc icmp packet, áp lên extension conntrack, chỉ lọc những packet có state new, nhảy tới chain RATE-LIMIT
                     iptables --append INPUT --protocol icmp --match conntrack --ctstate NEW --jump RATE-LIMIT
              # dùng ext limit, cứ mỗi lần vưọt quá 10 connection 1s, sẽ trừ đi 1 token trong 5 token, và nếu hết 5 token các packet sau đó sẽ bị drop, ngược lại
       # cứ mỗi giây không vượt quá limit, token sẽ được phục hồi 1 đơn vị, tối đa là 5. Nói dễ hiểu, nếu cố tình DOS và server nhận từ một địa chỉ IP hơn 50 packet/s, sau 5 giây ip đó sẽ
#bị block cho tới khi trở về bình thường.
                     iptables --append RATE-LIMIT --protocal icmp --match limit --limit 50/sec --limit-burst 5 --jump ACCEPT
     #+end_src

#+end_src
*** TCP SYN flood


 #+DOWNLOADED: screenshot @ 2020-12-04 22:31:07
 [[file:_assets/2020-12-04_22-31-07_screenshot.png]]

 - Trong mọi kết nối TCP (dù có kèm HTTP) hay không đều tuân theo 1 quy tắc
  
   - First, the client sends a SYN packet to the server in order to initiate the connection. Client gửi tcp với syn flag (ta gọi là tắt là syn paket) tới server. Mục đích của packet này là báo cho server biết máy khách muốn tạo lập 1 connection. Syn ở đây là synchronize
   - The server then responds to that initial packet with a SYN/ACK packet, in order to acknowledge the communication. Server sẽ response bằng một tcp packet kèm 2 flag SYN/ACK. Ack ở đây là acknowledge. Để báo cho client biết rằng server sẽ chấp nhận kết nối nếu client tiếp tục. Đồng thời server sẽ bind một socket trên một cổng thuộc nhóm random (từ 49152 tới 65535)
   - Finally, the client returns an ACK packet to acknowledge the receipt of the packet from the server. After completing this sequence of packet sending and receiving, the TCP connection is open and able to send and receive data. Sau cùng, client sẽ gửi tiếp một ack packet khác tới server. Client cũng sẽ cũng mở socket trong 1 cổng random (từ 49152 đến 65535) và thực hiện kết nối
 - Ngoài ra, nếu muốn kết thúc một kết nối TCP, client hoặc server sẽ gửi packet với flag FIN+ACK packet với phiá còn lại. Quá trình này gọi là termination conection, là một four-way handshake, giao thức 4 giai đoạn
 - Giao thức đợi tín hiệu phản hồi kèm flag ack này giúp cho tcp có tính ổn định và hạn chế tối đa việc mất dữ liệu (reliable) và nhờ đó những giao thức được xây dựng phiá trên nó (như HTTP,FTP) sẽ kế thừa tính này.
 - Nhưng cũng vì thế mà cá kỹ thuật tấn công lợi dụng giao thức này ra đời, ở đây, ngay khi server phản hổi client với ACK+SYN packet (ở bước 2), nó sẽ bắt đầu mở 1 socket 1 cổng dù chưa thực hiện kết nối. Ta gọi là half-connection, server sẽ đợi cho client trả lời bằng ACK packet. Nếu client cố tình không trả lời hoăc kéo dài thời gian trả lời. Cổng đang half-open đây sẽ trở nên hao phí. Từ đây nếu attacker cố tình gửi hàng loạt các packet SYN cùng một lúc. Sẽ dẫn đến việc nạn nhân mở hàng loạt các cổng và bị quá tải.
 - Lấy ví dụ minh họa bởi hping gửi duy nhất 1 SYN packet tới server
  [[file:_assets/2020-12-04_23-23-18_screenshot.png]]

  - Và server sau khi đợi trả lời không thành công sẽ gửi về tiếp một packet với flag RST. RST là reset, là flag báo về từ server nếu kết 3-way handsake thất bại
   [[file:_assets/2020-12-04_23-22-41_screenshot.png]]

 - Ta cũng thấy thời gian của một half-open rất ngắn, đo bằng ms. nhưng chỉ với hàng triệu tcp syn packet cùng được gửi. Đủ để làm quá tải bất kỳ hệ thống nào.


 #+begin_src shell
 hping -S -p 80 10.0.0.1 -i u100 --rand-source > /dev/null
 #+end_src
 Ta dùng câu lệnh trên ở cả 3 client blackarch cùng một lúc. Tốc độ gửi là 1000 packet/s. flag "-S" bảo hping gửi packet với syn flag. Nếu không hping mặc định sẽ gửi tcp packet không có flag nào cả và sẽ bị drop ngay lập tức.

 Và kết quả nhận đượng khi cố gắng gửi packet ICMP (ping) và TCP syn từ một client thường (với tốc độ 1 packet/s)

 #+DOWNLOADED: screenshot @ 2020-12-05 00:04:45
 [[file:_assets/2020-12-05_00-04-45_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-05 00:05:11
 [[file:_assets/2020-12-05_00-05-11_screenshot.png]]

 - Và đây là khi ping nếu server không bị tấn công
   #+DOWNLOADED: screenshot @ 2020-12-05 00:06:00
   [[file:_assets/2020-12-05_00-06-00_screenshot.png]]


 - Từ phiá phòng thủ: centos ta dùng snort với rules
   #+begin_src snort
   alert tcp !$HOME_NET any -> $HOME_NET 80 (flags:S;msg:"alert!!!! Some script kiddy try to tcp syn flood your on port 80."; flow: stateless; threshold: type threshold, track by dst,count 10,second 60 ;sid:1000002)
   #+end_example

 #+DOWNLOADED: screenshot @ 2020-12-05 00:22:37
 [[file:_assets/2020-12-05_00-22-37_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-05 00:23:02
 [[file:_assets/2020-12-05_00-23-02_screenshot.png]]

**** Iptables:
     #+begin_src fish
       # tạo một chain mới
       iptables --new-chain RATE-LIMIT
       # lọc icmp packet, áp lên extension conntrack, chỉ lọc những packet có state new, nhảy tới chain RATE-LIMIT
       iptables --append INPUT --protocol tcp --match conntrack --ctstate NEW --jump RATE-LIMIT
       # dùng ext limit, cứ mỗi lần vưọt quá 50 connection 1s, sẽ trừ đi 1 token trong 5 token, và nếu hết 5 token các packet sau đó sẽ bị drop, ngược lại
       # cứ mỗi giây không vượt quá limit, token sẽ được phục hồi 1 đơn vị, tối đa là 5. Ngắn gọn hơn, nếu cố tình DOS và server nhận từ một địa chỉ IP hơn 50 packet/s, sau 5 giây ip đó sẽ
       #bị block cho tới khi trở về bình thường.
       iptables --append RATE-LIMIT --protocal tcp --match limit --limit 50/sec --limit-burst 5 --jump ACCEPT
     #+end_src



* Topo 2:
  - Cài đặt snort ở gateway của network
  - Sử dụng port mirroring
  - Dùng dvwa - một web application hoàn chỉnh


#+DOWNLOADED: screenshot @ 2020-12-18 23:18:42
[[file:_assets/2020-12-18_23-18-42_screenshot.png]]

** Cài đặt RITE (port-mirror) trên router Server-area
    - RITE ( router IP traffic export) là một kỹ thuật port-mirroring  dùng để export (hay clone ) các packet đi qua một interface A tới 1 interface B trên cùng một router. Mà ứng dụng thực tế của nó là dùng để gửi một bản clone của các packet tới máy cài IDS, vì ta không thể cài IDS trực tiếp trên router mà chỉ có cài trên end-device.
    - Trong ví dụ này ta clone các packet gửi qua e0/0 (gateway của network 10.0.0.0/8) tới e0/1 (gw của 172.16.0.0/16) và dẫn nó tới int có MAC address là da83.e86b.80b5
#+begin_src python
  # Đưa vào mode config-rite
    server-area(config)#ip traffic-export profile From-e0-To-e1
  # export interface
    server-area(conf-rite)#int e0/1     

  # DEstination MAC addr, ta dùng ip link trên snort-on-centos để lấy 
    server-area(conf-rite)#mac-address da83.e86b.80b5
    server-area(conf-rite)#bidirectional
  # Cứ mỗi 5 packet clone 1 packet, để giảm băng thông trên đường truyền
    server-area(conf-rite)#incoming sample one-in-every 5
    server-area(conf-rite)#outgoing sample one-in-every 5
  # Monitored interface
    server-area(config)#int e0/0
    server-area(config-if)#ip traffic-export apply From-e0-To-e1
#+end_src

    - Kiểm tra xem port-mirroring có thàng công không
    - Trên router

 #+DOWNLOADED: screenshot @ 2020-12-16 18:45:42
 [[file:_assets/2020-12-16_18-45-42_screenshot.png]]
    - Ta ping từ 1 client bất kỳ không phải network 10.0.0.0/8(chứa server) và từ network 172.16.0.0/16 (chứa snort-server) --> 10.0.0.10

 #+DOWNLOADED: screenshot @ 2020-12-16 18:47:18
 [[file:_assets/2020-12-16_18-47-18_screenshot.png]]
    - Ta dùng snort ở máy có địa chỉ 172.16.0.10:

 #+DOWNLOADED: screenshot @ 2020-12-16 18:48:51
 [[file:_assets/2020-12-16_18-48-51_screenshot.png]]

 - Ta thấy RITE đã thành công, khi mà 2 network hoàn toàn khác nhau là 10.0.0.0/8 và 172.16.0.0/16 , các packet được gửi tới A đã clone 1/5 tới B, nơi chứa snort, và nếu có bất kỳ cuộc tấn công nào xảy ra, snort sẽ ghi nhận được. Ưu điểm của cácl lắp đặt Topo này:
   - Hệ thống IDS capture tất cả các gói tin đi vào network cần được bảo vệ
   - Do IDS nằm trên một hệ thống độc lập, IDS không bị tổn hại và tiếp tục hoặt động dù hệ thống bị tấn công có tổn hại hay không. Ta cũng có thể đặt thêm các hệ thống bảo vệ, như ẩn đi ip của network chứa snort. Như vậy các hệ thống thám tính không ghi nhận được vịêc dùng IDS trên hệ thống.
   - Dùng được với nhiều network khác nhau, ta có thể port-mirroing từ nhiều network khác nhau tới cùng một máy chưa IDS. Thay vì phải cài snort trên từng máy. Cũng như khả năng chỉ trích 1 phần nhỏ packet để clone gửi tới IDS giúp giảm sức chịu đựng của hệ thống IDS
- Cũng như TCP là một giao thức được xây dựng như một lớp abstraction phiá trên IP, HTTP là một giao thức được xây dựng ngay trên nền tảng của các giao thức thuộc các layer phiá dướt của OSI model. HTTP là hypertext transfer protocol, dùng để vận chuyển các dữ liệu dưới dạng nhìn thấy được bởi người dùng thông thường trong môi trường internet. HTTP có thể được xây trên nền TCP hoặc UDP, thuờng là TCP để thừa kế tính đảm bảo của nó. HTTP kết hợp với giao thức bảo mật SSL ta gọi là HTTPS.

** Application layer DOS - HTTP  attack:
  - Ta chạy một apache server trên centos và truy cập cổng 80 từ client với w3m:
    #+begin_src shell
    root@centos-server /e/httpd# httpd
    root@client /# w3m 10.0.0.1
    #+end_src
- Nội dung trên websever cổng 80 của DVWA server 

[[file:_assets/2020-12-16_23-49-40_screenshot.png]]
- Dùng wireshark để phân tích kết nối http này, ta thấy có tới hơn 10 packet được trao đổi qua lại nhưng chỉ có 2 dòng là HTTP, còn lại đều là TCP (SYN,ACK,FIN), nó cho thấy HTTP chỉ là một protocal phụ thuộc vào protocol ở layer thấp hơn.
- Diễn giải: client sẽ gửi TCP ack để bắt đầu 3-way-handshake như ta đã giải thích ở ví dụ liền trước. Sau khi đảm bảo kết nối được establish. HTTP request sẽ được gửi đi. Ta nhận diện bằng HTTP header với dòng GET là flag của HTTP, và 1.0 là version của HTTP. Sau đó giữa 2 endnode sẽ bắt có 1 quá trình trao đổi TCP ack và psh. Psh là push flag báo rằng data phải được chuyển ngay tới phiá bên kia, vì data ở HTTP thuờng có dung lượng rất lớn và phải được chia nhỏ ra trước khi gửi, flag này nhằm thúc đẩy nhanh quá trình gửi data. Ở bài thuyết trình này không đi sâu vào. Server reponsse với status 443 vì ta không đặt bất kỳ trang web nào trên trang chủ. Ngay sau khi respone. Vì thấy rằng không cần thiết để duy trì kết nối nữa, máy chủ chủ động gửi tcp fin để bắt đầu quá trình kết thúc TCP connection.
#+DOWNLOADED: screenshot @ 2020-12-05 00:42:28
[[file:_assets/2020-12-05_00-42-28_screenshot.png]]

- Như ta đã thấy, HTTP tốn rất ít nhất gấp 2 lần số giai đoạn so với 1 TCP thông thưòng và thậm chí nếu thông qua HTTPS ta còn tốn thêm 2 lần nữa. Do SSL là 3-way-handshake protocal. Và dĩ nhiên bản thân mỗi kết nối HTTP có thể duy trì rất lâu(như khi download file media...). Do đó kiểu tấn công HTTP/HTTPS thường gây tổn hại nặng nề hơn so với các kiểu nêu trước đây. Cách vận hành của kiểu tấn công này cũng gần tương tự, lợi dụng cơ chế bảo toàn dữ liệu handshake qua nhiều giai đoạn, attacker hoặc cố gắng duy trì quá trình half-open càng lâu càng tốt, hoặc ngược lại duy trì quá trình kết nối establist connection càng lâu càng tốt cũng như gửi càng nhiêu kết nối . Từ đó làm máy tính nạn nhân cạn kiệt khả năng để response các kết nối thông thường.
  - Ta không dùng hping nữa vì công cụ này không hỗ trợ giao thức http.
  - Dùng slowloris, một công cụ chuyên dùng cho DDOS với giao thức HTTP/HTTPS.
  - Ở kiểu tấn công bằng HTTP, lại có 2 hướng chính là Flood (gửi càng nhiều kết nối và packet càng tốt) và slow-and-low ( gửi ít kết nối hơn nhưng cố gắng duy trì kết nối thật lâu ).
  - Slowloris mặc định dùng hướng slow-and-low attack, tức là thay vì cố gắng gửi thật nhiều packet, cách tấn công này chỉ gửi một số lượng packet thấp hơn nhiều (khi ta nói packet tức là packet dùng để request connection với server). Nhưng đảm bảo các packet sẽ lập được kết nối với server. Lợi dụng một điểm yếu của một số web browser, trong đó có Apache, là giới hạn trong số lượng kết nối tốt đa có trong mỗi thời điểm. Slow-and-low sẽ dễ dàng làm một web-server không được bảo vệ mất hoàn toàn khả năng hoạt động 
- Ta thử nghiệm slowloris với 1 kết nối
  #+begin_src perl
  root@blackarch-3 /# slowloris-py  -s 1 -p 80 10.0.0.1 --sleeptime 30
  #+end_src
  #+begin_example
  -s : số lượng socket, ở đây ta chỉ đặt 1
  -p 80 : port 80
  --sleeptime 30. Mỗi kết nối sẽ được restart sau 30s
  #+end_example
  - Từ wireshark, ta thấy slowlorish thành công trong việc giữ kết nối này tới 20s tới khi bị server chủ động huỷ kết nối 
#+DOWNLOADED: screenshot @ 2020-12-05 01:40:37
[[file:_assets/2020-12-05_01-40-37_screenshot.png]]

*** Tấn công HTTP - Slow and Low DOS vào Snort: 

     - Kiểm tra xem server có hoạt động bình thường không.
     - Dùng một máy ảo với firefox  để kiểm tra
       #+DOWNLOADED: screenshot @ 2020-12-16 19:01:45
       [[file:_assets/2020-12-16_19-01-45_screenshot.png]]

       [[file:_assets/2020-12-16_23-48-40_screenshot.png]]
 - Tiếp theo ta set up snort với rule như sau trên centos server
 - Đây là snort rules ta dùng để phát hiện http request tới cổng 80    
 #+begin_src snort
 alert tcp !$HOME_NET any -> $HOME_NET 80 (msg:"Those kids attack by http!!!";content:"HTTP"; threshold: type threshold, track by_dst , count 100, seconds 1; sid: 1000003; rev:1)
 #+end_src
 - Dùng câu lệnh để chạy snort:
 #+begin_src shell
 centos-server #  snort -A console -c /etc/snort/snort.conf
 #+end_src
 - Tiếp theo ta dùng slowloris.py (slowloris có 2 phiên bản viết bằng perl và python) với câu lệnh như sau trên cả 3 máy attacker. 
 #+begin_src cperl
 root@blackarch-2 /# slowloris-py -p 80  --sleeptime 10 10.0.0.1
 root@blackarch-3 /# slowloris-py -p 80  --sleeptime 10 10.0.0.1
 root@blackarch-1 /# slowloris-py -p 80  --sleeptime 10 10.0.0.1
 #+end_src
 - Ta thấy slowloris sẽ tạo ra các kết nối trên các socket khác nhay và cố gắng duy trì các kết nối này càng lâu càng tốt với keep-alive header

 #+DOWNLOADED: screenshot @ 2020-12-08 11:35:46
 [[file:_assets/2020-12-08_11-35-46_screenshot.png]]

 - Và trên snort ngay lập tức báo lại như sau
 #+DOWNLOADED: screenshot @ 2020-12-08 11:35:59
 [[file:_assets/2020-12-08_11-35-59_screenshot.png]]


 - Kiểm tra bằng 1 client bất kỳ truy cập tới web-server nạn nhân. Tha thấy kết nối bị trì hoãn cực kỳ
 #+DOWNLOADED: screenshot @ 2020-12-08 11:44:15
 [[file:_assets/2020-12-08_11-44-15_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-08 11:44:38
 [[file:_assets/2020-12-08_11-44-38_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-08 11:45:44
 [[file:_assets/2020-12-08_11-45-44_screenshot.png]]

**** Dùng mod-security để chặn:

#+begin_src apache
  # Đoạn rules này trích từ mod_sec core_rule_sec
# Ở phiên bản gần đây người dùng nên thêm config SecConnEngine On để kích hoạt RESPONSE status, nếu không sẽ ModSec sẽ không trả về kết quả như ý
    SecRule RESPONSE_STATUS "@streq 408" "phase:5,id:'981051',t:none,nolog,pass,setvv
    ar:ip.slow_dos_counter=+1,expirevar:ip.slow_dos_counter=120"
    SecRule IP:SLOW_DOS_COUNTER "@gt 3" "phase:1,id:'981052',t:none,log,drop,msg:'Cll
    ient Connection Dropped due to high %{ip.slow_dos_counter} request of slow DoS alerts'"
#+end_src
- Diễn giải: Không như kiểu Dos dựa trên volumn vốn gửi thật nhiều kết nối mới và ta có thể filter dựa trên số kết nối mỗi giây, slow&low attack duy trì một lượng kết nối tương nối vừa phải và chỉ reset các kết nối này sau 1 khoảng thời gian, do đó ta cần cách tiếp cận khác
  - Slowloris.pl và các tool tương tự hoạt động theo nguyên tắc giả vờ muốn mở kết nối với server nạn nhân, nhưng không thật sự gửi, và chúng duy trì kết nối ấy với các packet syn liên tục cho tới khi máy chủ chủ động drop connection và trả về HTTP_response với status 408
  - Nên ta chỉ cần filter theo RESPONSE_STATUS, tạo một ip.dos_counter với timeout 120s. Nếu trong 60s mà ip này gửi trên 5 kết nối sẽ bị drop.
  #+DOWNLOADED: screenshot @ 2020-12-23 15:36:37
  [[file:_assets/2020-12-23_15-36-37_screenshot.png]]

  - Demo:
  - Dùng script sau để dễ theo dõi số concurent connection in port 80
     #+begin_src perl
       #!/usr/bin/perl
       use warnings;
       use strict;
       $> == 0 ? () : due "run as root please";
       `cat > bin.sh << EOF
                                 #!/bin/sh
                              echo "So concu connection tren port 80 la \n"
                            ss -tpna |grep : 80 | wc -l
                        EOF
                     `;
       system ("chmod +x bin.sh");
       system ("watch -n1 ./bin.sh");
     #+end_src
     #+DOWNLOADED: screenshot @ 2020-12-24 10:11:06
     [[file:_assets/2020-12-24_10-11-06_screenshot.png]]
- Khi dùng slowloris hoặc tương tự
  #+DOWNLOADED: screenshot @ 2020-12-24 10:11:38
đ  [[file:_assets/2020-12-24_10-11-38_screenshot.png]]
- Ngay sau khi ta thêm Mod_sec rule như trên vào,sau 60s để chờ rules phát huy kết quả
  #+DOWNLOADED: screenshot @ 2020-12-24 10:14:43
  [[file:_assets/2020-12-24_10-14-43_screenshot.png]]

  #+begin_comment


**** Non-dos                                                       :noexport:
 - NTP amplication dos attack
 - UDP-DNS flood attack
 - DNS amplication attack
 #+end_comment

*** HTTP flood - volumn attack:

     - Trái ngược với kiểu slow-low, ta gửi thật nhiều http connection càng tốt tới nạn nhân, dù phần lớn sẽ nhanh chóng bị bỏ drop.
     - Thay đổi trên dòng lệnh ~hulk~.

  #+begin_src shell
 hulk http://10.0.0.1
  #+end_src

 #+DOWNLOADED: screenshot @ 2020-12-17 21:17:03
 [[file:_assets/2020-12-17_21-17-03_screenshot.png]]

  - Capture bằng wireshark
  - Ta thấy từ từ ~21:15:08~ tới ~21:15:09~ tức 1s ~hulk~ đã gửi hơn 600 http connection. Chỉ trên 1 máy 


 #+DOWNLOADED: screenshot @ 2020-12-17 21:18:16
 [[file:_assets/2020-12-17_21-18-16_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-17 21:18:26
 [[file:_assets/2020-12-17_21-18-26_screenshot.png]]
 - Dùng Snort

   #+DOWNLOADED: screenshot @ 2020-12-17 21:21:37
   [[file:_assets/2020-12-17_21-21-37_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-17 21:22:23
 [[file:_assets/2020-12-17_21-22-23_screenshot.png]]
 - Ta thấy số packet nhận về thấp hơn rất nhiều. Điều đó hoàn toàn hợp lý vì port mirroring ta chỉ trích 1 phần nhỏ gửi tới snort. Nhờ đó giảm tải cho hệ thống IDS rất nhiều, nhất là khi phải theo dõi nhiều mạng lưới khác nhau.
 - Dùng mod_security:
 #+begin_src apache
SecAction id:1009,phase:1,initcol:ip=%{REMOTE_ADDR},nolog

SecAction id:1010,phase:1,nolog,pass,setvar:IP.counter=+1
SecRule  IP:UPDATE_RATE "@gt 1" \
"id:1011,phase:1,block,msg:'Request rate too high for IP address: %{REMOTE_ADDR} with rate : %{ip.update_rate}'"
 #+end_src

#+DOWNLOADED: screenshot @ 2020-12-24 10:45:58
- Dùng hulk trước khi dùng mod_Sec
[[file:_assets/2020-12-24_10-45-58_screenshot.png]]
- Sau khi dùng mod_sec với rules như trên
  
#+DOWNLOADED: screenshot @ 2020-12-24 10:40:49

#+DOWNLOADED: screenshot @ 2020-12-24 11:41:24
[[file:_assets/2020-12-24_11-41-24_screenshot.png]]

**** Ping of Death                                                 :noexport:
  - Dùng ping mặt định, length của mỗi ICMP packet là 42
 #+begin_src python
 ping   10.0.0.1     
 #+end_src
 Ngoài ra, mỗi ping gửi đi sẽ có 1 ping quay về

 #+DOWNLOADED: screenshot @ 2020-12-17 21:44:12
 [[file:_assets/2020-12-17_21-44-12_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-17 21:36:57
 [[file:_assets/2020-12-17_21-36-57_screenshot.png]]

  - Dùng hping với flag "-s"  là 1000. Ta thấy packet length thay đổi 
  - Mỗi ping gửi đi cũng sẽ có 1 ping response tương ứng
    #+begin_src shell
    ping -s 1000 10.0.0.1
    #+end_src

 #+DOWNLOADED: screenshot @ 2020-12-17 21:45:21
 [[file:_assets/2020-12-17_21-45-21_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-17 21:38:34
 [[file:_assets/2020-12-17_21-38-34_screenshot.png]]
  - Vậy nếu ta đặt data length với con số 100000 thì sao
 #+begin_src python
 ping -d 60000 -1 10.0.0.1 -i u100
 #+end_src

 #+DOWNLOADED: screenshot @ 2020-12-17 21:40:58
 [[file:_assets/2020-12-17_21-40-58_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-17 21:45:44
 [[file:_assets/2020-12-17_21-45-44_screenshot.png]]
  - Chúng ta thấy xuât hiện cột  ~Reassembled IPv4 length~ , có sự phản hồi từ máy nhận (trên wireshark), nhưng trên command line của ping không hề xuất hiện. Cho thấy đây là một hành vi không bình thường. Thật vậy, Ping of Death (PoD) là lợi dụng sự giới hạn trong MTU (maximum transmision unit) trong mỗi PDU ( protocol data unit). PDU là chỉ mỗi đơn vị trao đổi trong hệ thống OSI. Mỗi layer khác nhau dùng một PDU khác nhau
    - Layer 4 dùng segment hay datagram
    - Layer 3 dùng packet
    - Layer 2 dùng frame
    - Layer 1 dùng bit
  - Đôi khi, trong ngữ cảnh thông thường. Ta hay dùng cụm từ packet để chỉ mọi đơn vị trao đổi trong network, như một cách thuận tiện trong giao tiếp, dù chúng không chuẩn về mặt lý thuyết.
  - Quay lại vấn đề chính, mỗi ICMP packet được trao đổi với nhau rất đa dạng về kích thướng, thông thường rất nhỏ như là 42 byte khi ping thông thường và có thể lên tới tối đa ~ 64000 byte. Tuy nhiên, ở lớp thất hơn, layer2 , mỗi PDU là frame chỉ giới hạn tối đa 1500 byte

    #+DOWNLOADED: screenshot @ 2020-12-17 22:02:40
    [[file:_assets/2020-12-17_22-02-40_screenshot.png]]

    - Điều này dẫn đến khái niệm, fragment packet. Nghĩa là mỗi gói tin ICMP nếu có kích thước lớn phải được chia nhỏ ra rồi gửi đi, đồng thời khi tới mục tiêu nó sẽ được nối lại .

    - Vấn đề là nhiều máy tính không được thiết kế để xử lý tình huống nếu gói tin được nói lại lớn hơn kích thước maximum (64KB). Dẫn đế việc nếu kẻ tấn công cố tình gửi hàng loạt các packet có kích thước cực lớn, sẽ gây ra cạn kiệt tài nguyên trên máy nhận.

    - Ta thấy mặt định ping không cho phép gửi gói tin lớn hơn kích thuớc 64KB
      #+DOWNLOADED: screenshot @ 2020-12-17 22:08:22
      [[file:_assets/2020-12-17_22-08-22_screenshot.png]]

      - Vậy nên ta dùng hping, với interval u1000, nghĩa là gửi 100 packet với kích thước 200KB mỗi packet tới nạn nhân

 #+begin_src shell
 hping -d 200000 -i u1000 -1 10.0.0.1
 #+end_src


** Non-Dos Attack :

*** SQL injection
 - Dùng nmap, ta biết server đang sử dụng mysql data

 #+DOWNLOADED: screenshot @ 2020-12-18 20:49:16
 [[file:_assets/2020-12-18_20-49-16_screenshot.png]]
     - Sau đó ta kiểm tra tiếp bằng cách nhập một input bất kỳ bắt đầu bằng ~'~ , output từ webserver sẽ làm lộ việc dùng sql cũng như có thể nhập sql vào
       #+DOWNLOADED: screenshot @ 2020-12-18 20:52:12
 [[file:_assets/2020-12-18_20-52-12_screenshot.png]]

       - Vậy ta thử exploit bằng tay.

 #+DOWNLOADED: screenshot @ 2020-12-18 20:17:25
 [[file:_assets/2020-12-18_20-17-25_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-18 20:17:04
 [[file:_assets/2020-12-18_20-17-04_screenshot.png]]

 #+begin_src sql
 ‘ union all select load_file(‘/etc/passwd’),null #
 #+end_src
 #+DOWNLOADED: screenshot @ 2020-12-18 20:47:45
 [[file:_assets/2020-12-18_20-47-45_screenshot.png]]


  - Với một payload đơn giản đã để lộ rất nhiều data. Nguyên nhân của lỗi này nằm ngay trong source code
 #+begin_src php
   <?php

   if( isset( $_REQUEST[ 'Submit' ] ) ) {
           // Get input

           $id = $_REQUEST[ 'id' ];
         // Attacker chỉ cần có kiến thức về sql và php, bất kỳ dòng code sql nào sẽ được inject trực tiếp vào $query và thực thi.
           // Check database
           $query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id''
   ;";
         // $query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; Thêm LIMIT 1 vào cuối dòng này là một trong những cách ngăn chặn hữu hiệu nhất trong trường hợp này
           $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) (cond) ? then : else; mysq
   li_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );
  #+end_src

  - Phần trên chỉ để hiểu cách mà sqli hoặt động (một cách cơ bản), tuy nhiên trong nội dung của bài tiểu luận này, vốn tập trung vào snort nói riêng và IDS nói chung, ta tìm hiểu về cách khai thác lỗi sqli một cách tự động và dùng snort để phát hiện và ngăn chặn nó.
  - Ở đây ta dùng ~SQLmap~ kết hợp với ~Zap proxy~.
    - Zap proxy cho phép ta capture các http request ta gửi tới server nạn nhân
    - Với input ~1~

 #+DOWNLOADED: screenshot @ 2020-12-18 20:58:58
 [[file:_assets/2020-12-18_20-58-58_screenshot.png]]

      #+DOWNLOADED: screenshot @ 2020-12-18 20:58:42
 [[file:_assets/2020-12-18_20-58-42_screenshot.png]]

 - Dùng thông tin capture được ta bỏ vào sqlmap
 - Trên máy ~root@kali~ ta dùng sql map:
 - 
 #+begin_src shell
 sqlmap --url="http://10.0.0.1/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=ejrjp5450f9bagliolqtrrgtv6; security=low" --dump
 #+end_src

 #+DOWNLOADED: screenshot @ 2020-12-18 21:12:27
 [[file:_assets/2020-12-18_21-12-27_screenshot.png]]

 - Cách tấn công này nhìn có vẻ đơn giản và dễ dàng, nhưng thực tế chỉ cần kiểm tra bằng wireshark, ta thấy sqlmap đã gửi hàng chục ngìn tcp packet/http request để thử các trường hợp khác nhau. Dễ thấy đây là một kiểu tấn công bruteforce
   - 
   #+DOWNLOADED: screenshot @ 2020-12-18 21:14:11
   [[file:_assets/2020-12-18_21-14-11_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2020-12-18 21:14:26
 [[file:_assets/2020-12-18_21-14-26_screenshot.png]]

 - Và dĩ nhiên, việc bruteforce một cách "ồn ào" như vậy sẽ dễ dàng bị phát hiện bằng IDS như snort
   #+begin_src snort
   alert tcp !$HOME_NET any -> $HOME_NET 80 (msg:"SQL injection attemp from script kiddies"; content:"/vulnerabilities/sqli/?id="; pcre:"/\/sqli\/?id=[0-9]{1-5}\sHTTP.*/i"; sid:100005;rev:1)
   #+end_src
   - Lý giải: so sánh sự khác biệt giữa một request bình thường và một request với sqlmap:
     #+begin_src shell
 vulnerabilities/sqli/?id=1&Submit=Submit 
     /vulnerabilities/sqli/?id=1%27%20AND%201297%3D1297%20AND%20%27gsCv%27%3D%27gsCv&Submit=Submit
     #+end_src
 Do đó ta dùng pcre
 - ~pcre~ là lọc dựa trên perl regrex, trừ những request với id={number}&Submit=Submit ra tất cả các hình thức khác sẽ bị báo động, dĩ nhiên là phải gửi tới địa chỉ /vulnerabilities/sqli/?id= , dấu ~!~ dùng ngay đằng trước regrex nghĩa là loại ngược lại. 

   #+DOWNLOADED: screenshot @ 2020-12-18 22:14:14
 [[file:_assets/2020-12-18_22-14-14_screenshot.png]]
 - Ta check lại với các request thông thường, input kiểu thông thường vào
   #+DOWNLOADED: screenshot @ 2020-12-18 22:34:19
 [[file:_assets/2020-12-18_22-34-19_screenshot.png]]
 - Và snort không báo động gì cả
   #+DOWNLOADED: screenshot @ 2020-12-18 22:34:43
 [[file:_assets/2020-12-18_22-34-43_screenshot.png]]
     
*** Command Injection:
#+begin_comment
Command injection is an attack in which the goal is execution of arbitrary commands on the host operating system via a vulnerable application. Command injection attacks are possible when an application passes unsafe user supplied data (forms, cookies, HTTP headers etc.) to a system shell. In this attack, the attacker-supplied operating system commands are usually executed with the privileges of the vulnerable application. Command injection attacks are possible largely due to insufficient input validation.

This attack differs from Code Injection, in that code injection allows the attacker to add their own code that is then executed by the application. In Command Injection, the attacker extends the default functionality of the application, which execute system commands, without the necessity of injecting code.
#+end_comment
- Command injection có mục tiêu là kích hoạt một command (thường là shell) lên hệ điều hành của mục tiêu. Nó dựa trên những lỗ hổng do việc thiết kế web application một cách không cẩn thẩn. Cho phép người dùng nhập dữ liệu vào và kích hoạt system shell. Nhưng do không giới hạn hết các trường hợp có thể xảy ra nên attacker có thể nhúng vào những dòng shell gây nguy hại cho hệ thống.
  #+begin_src php
    if( isset( $_POST[ 'Submit' ]  ) ) {
        // Get input
        $target = $_REQUEST[ 'ip' ];
    // Dòng shell_exec được kích hoạt một cách quá sơ sài, hoàn toàn không filter. Dùng một filter đơn giản như sau
    // $substitutions = array(
    // 	'&'  => '',
    // 	';'  => '',
    // 	'| ' => '',
    // 	'-'  => '',
    // 	'$'  => '',
    // 	'('  => '',
    // 	')'  => '',
    // 	'`'  => '',
    // 	'||' => '',
    // );
// Là sẽ chặn được rất nhiều cố gắng theo hướng này
    //     // Determine OS and execute the ping command.
        if( stristr( php_uname( 's' ), 'Windows NT' ) ) {
            // Windows
            $cmd = shell_exec( 'ping  ' . $target );
        }
        else {
            // *nix
            $cmd = shell_exec( 'ping  -c 4 ' . $target );
        }

        // Feedback for the end user
        $html .= "<pre>{$cmd}</pre>";
    }

  #+end_src
#+caption: Input bình thường
#+DOWNLOADED: screenshot @ 2020-12-22 03:37:28
[[file:_assets/2020-12-22_03-37-28_screenshot.png]]
#+DOWNLOADED: screenshot @ 2020-12-22 03:44:22
#+caption: nhúng command vào
[[file:_assets/2020-12-22_03-44-22_screenshot.png]]
- Khi đã biết có thể nhúng shell command vào được, ta biết attacker có thể dùng tool để tự động quá trình exploit:
#+begin_src shell
commix -u "http://10.0.0.1/vulnerabilities/exec/" --data="ip=1.1.1.1&Submit=Submit" --cookie="PHPSESSID=g7hj2o78119r1pdjsu3vpbbet6; security=low" --all -v 4 --flush-session
#+end_src

#+DOWNLOADED: screenshot @ 2020-12-22 03:48:54
[[file:_assets/2020-12-22_03-48-54_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-22 03:49:11
[[file:_assets/2020-12-22_03-49-11_screenshot.png]]
**** Cách phòng thủ:
   |                      | POST DATA                     |
   |----------------------+-------------------------------|
   | request thông thường | 1.1.1.1 (%ddd.%ddd.%ddd.%ddd) |
   | request from commit  | tất cả những thứ còn lại      |
   - Tất cả mọi hướng phòng thủ đều chỉ hướng tới filter mọi output không có dạng %ddd.%ddd.%ddd.%ddd
***** Với IDS/snort:
   #+begin_src snort
     alert tcp !$HOME_NET any -> $HOME_NET 80 (msg:"Seem like command injection attempt from those little kid";\
         content:"/vulnerabilities/exec/";http_uri; \
         content:"ip=";pcre:!"/ip=\d{1-3}\.\d{1-3}\.\d{1-3}\.\d{1-3}&Submit=Submit/i";http_client_body;\
         sid:1000006;rev:1)
   #+end_src
   - Snort alert request từ commix
   #+DOWNLOADED: screenshot @ 2020-12-22 08:49:58
   [[file:_assets/2020-12-22_08-49-58_screenshot.png]]
   - Nhập thông thường
   #+DOWNLOADED: screenshot @ 2020-12-22 08:59:35
   [[file:_assets/2020-12-22_08-59-35_screenshot.png]]

   #+DOWNLOADED: screenshot @ 2020-12-22 08:59:58
   [[file:_assets/2020-12-22_08-59-58_screenshot.png]]

   # Rules
***** Với mod_security:
- Thay vì ~reinvent the wheel~ ta dùng mod-security core rule set
  #+begin_src shell
ln /usr/share/modsecurity-crs/modsecurity_crs_41_sql_injection_attack.conf /etc/modsecurity/
  #+end_src
- Phân tích sơ lược về các rules trong file này
  #+begin_src perl
  #Trích code không lấy comment
perl -ne 'print if !/^#/' /usr/share/modsecurity-crs/modsecurity_crs_41_sql_injection_attack.conf
  #+end_src
  #+begin_src shell
            # khoản 123 rules
    # tựu trung tập trung filer cookie và các arg trong request để tìm các từ khoá đáng ngờ của sql language và deny cá request như thế
        SecRule REQUEST_COOKIES|!REQUEST_COOKIES:/__utm/|REQUEST_COOKIES_NAMES|ARGS_NAMES|ARGS|XML:/* "(?i:(?:[\"'`´’‘]\s*?\*.+(?:x?or|div|like|between|and|id)\W*?[\"'`´’‘]\d)|(?:\^[\"'`´’‘])|(?:^[\w\s\"'`´’‘-]+(?<=and\s)(?<=or|xor|div|like|between|and\s)(?<=xor\s)(?<=nand\s)(?<=not\s)(?<=\|\|)(?<=\&\&)\w+\()|(?:[\"'`´’‘][\s\d]*?[^\w\s]+\W*?\d\W*?.*?[\"'`´’‘\d])|(?:[\"'`´’‘]\s*?[^\w\s?]+\s*?[^\w\s]+\s*?[\"'`´’‘])|(?:[\"'`´’‘]\s*?[^\w\s]+\s*?[\W\d].*?(?:#|--))|(?:[\"'`´’‘].*?\*\s*?\d)|(?:[\"'`´’‘]\s*?(x?or|div|like|between|and)\s[^\d]+[\w-]+.*?\d)|(?:[()\*<>%+-][\w-]+[^\w\s]+[\"'`´’‘][^,]))" "phase:2,capture,t:none,t:urlDecodeUni,deny,msg:'Detects classic SQL injection probings 2/2',id:'981243',tag:'OWASP_CRS/WEB_ATTACK/SQL_INJECTION',logdata:'Matched Data: %{TX.0} found within %{MATCHED_VAR_NAME}: %{MATCHED_VAR}',severity:'2',setvar:'tx.msg=%{rule.id}-%{rule.msg}',setvar:tx.sql_injection_score=+1,setvar:tx.anomaly_score=+%{tx.critical_anomaly_score},setvar:'tx.%{tx.msg}-OWASP_CRS/WEB_ATTACK/SQLI-%{matched_var_name}=%{tx.0}'"
# Ngoài ra tạo và thep dõi các biết tx.{***} để quyết định xem có nên block request hay không, tx (transaction collection )cũng như ip collection, là một built-in persisten collection lữu trữ dữ liệu về transaction
SecRule TX:SQLI_SELECT_STATEMENT "@containsWord select" "phase:2,id:'981301',t:none,pass,nolog,setvar:tx.sqli_select_statement_count=+1,setvar:tx.sql_injection_score=+1"
SecRule TX:SQLI_SELECT_STATEMENT "@containsWord show" "phase:2,id:'981302',t:none,pass,nolog,setvar:tx.sqli_select_statement_count=+1,setvar:tx.sql_injection_score=+1"
SecRule TX:SQLI_SELECT_STATEMENT "@containsWord top" "phase:2,id:'981303',t:none,pass,nolog,setvar:tx.sqli_select_statement_count=+1,setvar:tx.sql_injection_score=+1"
SecRule TX:SQLI_SELECT_STATEMENT "@containsWord distinct" "phase:2,id:'981304',t:none,pass,nolog,setvar:tx.sqli_select_statement_count=+1,setvar:tx.sql_injection_score=+1"
SecRule TX:SQLI_SELECT_STATEMENT "@containsWord from" "phase:2,id:'981305',t:none,pass,nolog,setvar:tx.sqli_select_statement_count=+1,setvar:tx.sql_injection_score=+1"
SecRule TX:SQLI_SELECT_STATEMENT "@containsWord dual" "phase:2,id:'981306',t:none,pass,nolog,setvar:tx.sqli_select_statement_count=+1,setvar:tx.sql_injection_score=+1"

    
  #+end_src
  - Test với dòng sqlmap sau và ta thấy sqlmap bị deny connection
    #+begin_src shell
    sqlmap -a --cookie="PHPSESSID=q26rlipdsjcmhavd0d1d43nb24[82/97862]│modsecurity_crs_30_http_policy.conf =low" -u "http://victim/vulnerabilities/sqli/?id=1&Submit=Submit" -- flush-session
    #+end_src
    #+DOWNLOADED: screenshot @ 2020-12-24 13:20:58
    [[file:_assets/2020-12-24_13-20-58_screenshot.png]]
- Check log_audit của modsec:
  #+DOWNLOADED: screenshot @ 2020-12-24 13:22:14
  [[file:_assets/2020-12-24_13-22-14_screenshot.png]]

  
*** XSS :
- Cross-site Scripting attack cố gắng nhúng code javascript vào trang web. Trong công nghệ web application nói chung, có 2 ngôn ngữ lập trình phổ biến nhất là PHP và JS. 
- Trong khi PHP hoạt động trực tiếp trên Server. Nghĩa là khi brower gửi request thì server sẽ vận hành code PHP để output ra kết quả và gửi về cho browser. Thì Javascript hoạt động ngay trên Browser. Nghĩa là khi người server trả về response chứa file html đính kèm với JS, code JS sẽ được dịch trực tiếp trên browser của người dùng.
- Vì bản thân server không nhận thức được sự tồn tại của JS nó gửi cho browser, do nó không trực tiếp kích hoạt code. Nên nếu bản thân người dev không cẩn thận, attacker sẽ nhúng JS vào chính server thông qua các input form.
- Nói đơn giản, giả sử attacker biết server sẽ tự động trả về một kết quả ABC nào đó nếu người gửi một request XYZ. Nhưng nếu server không có cơ chế lọc javascript . Attacker cố tính nhập vào javascript, và server, vẫn theo nguyên tắc, trả về kết quả có đoạn javascript ấy. Server không hề hay biết nó bị inject do nó không kích hoạt đoạn js này, đoạn js này chỉ kích hoạt trên browser của người dùng. Trong thực tế, nếu phát hiện một website có thể bị XSS, attacker sẽ cố gắng đánh lừa nạn nhân gửi request chứa XSS tới server ( ví dụ qua email có chưa link chứa các request này). Và khi browser trả về kết quả vốn chưa JS độc (ví dụ như kích hoạt một form cập nhật mật khẩu chẳng hạn). Người dùng vì yên tâm đó là từ server sẽ nhập thông tin nhạy cảm vào. 
- ví dụ: với dòng code ~<script>alert("kitty")</script>~ vào form bên dưới đã đủ để kích hoạt js. Đoạn payload này dùng được cho cả 2 challenge persistent(Store) XSS và reflect XSS.
  - Một web app có thể bị suffer từ XSS thường có source code như vầy
  #+DOWNLOADED: screenshot @ 2020-12-23 02:16:10
- Persistent XSS là khi mà JS lưu lại ngay trên server. ví dụ như trong trường hợp này
  #+begin_src php
    // Get input
    $name = htmlspecialchars( $_GET[ 'name' ] );
    // Feedback for end user
    echo "<pre>Hello ${name}</pre>"; 
  #+end_src
  - Hay như vầy
  #+begin_src php
    // Update database
        $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";
        $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );

        //mysql_close();
  #+end_src
  - Như trên thì payload được nhập vào bị lưu lại trên database và payload js sẽ tiếp tục được thực thi nếu người dùng trở lại kể cả với kết nối thông thường
#+DOWNLOADED: screenshot @ 2020-12-23 03:45:00
[[file:_assets/2020-12-23_03-45-00_screenshot.png]]

- Dĩ nhiên thực tế không dễ như thế, các dev thường sẽ bảo vệ web app của họ bằng các phương pháp khác nhau, mà thường nhanh nhất là áp dụng sanitizationn input. Nghĩa là filter đi những phần input có thể gây hại trước khi nó vào server (Như cụm từ ~<script>~ chẳng hạn). Do đó attack thường sự dụng những tool nhằm tự động hoá quá trình exploit.
#+begin_src shell
root@kali ~# xsser -u "http://10.0.0.1/vulnerabilities/xss_s/" --cookie="PHPSESSID=ciaqmol5nsqb2a9mght79aii66; security=low"  -p 'txtName=nhannht&mtxMessage=XSS&btnSign=Sign+Guestbook'  --auto-set=10 --save

#+end_src

#+DOWNLOADED: screenshot @ 2020-12-23 09:38:41
[[file:_assets/2020-12-23_09-38-41_screenshot.png]]
- XSSer hoặc các công cụ tương tự sẽ trả về kết quả nếu nó phát hiện, vì hoạt động theo cơ chế fuzzing,nên kết quả nhìn sẽ hơi rối mắt, chúng ta cần phải biết cách phân tích. ví dụ
  #+begin_src shell
  txtName=nhannht&mtxMessage=%22%3E%3CSCRIPT%3Ealert%28%2789aa030de30557f1baedee0d5f211875%27%29%3C%2FSCRIPT%3E&btnSign=Sign+Guestbook
  #+end_src
ta decode ra thành
#+begin_src shell
 txtName=nhannht&mtxMessage="><SCRIPT>alert('89aa030de30557f1baedee0d5f211875')</SCRIPT>&btnSign=Sign Guestbook
#+end_src
Ta chỉ lấy phần quan trọng nhất là ~<script>alert()</script>~ và dùng nó để test lại xem XSS có hoạt động với payload này không
- Dùng wireshare, ta thấy cách hoạt động của XSSer dựa theo cơ chế fuzzing, nghĩa là random input dựa trên một số mẫu có sẵn, một kiểu nâng cao hơn của dictionary attack, dù vậy việc dựa trên những mẫu có sẵn đó là luôn phải đi kèm với các html tag như <script><\script> hay <title><\title> hay một số cụm từ alert(),onMouseclick khiến cho việc phát hiện và ngăn chặn XSS khá dễ dàng
- Cách phòng thủ
- Với modsecurity:
  - Tương tự ta dùng mod-csr:
#+begin_src shell
ln /usr/share/modsecurity-crs/base_rules/modsecurity_crs_41_xss_attacks.conf /etc/modsecurity/
#+end_src
#+begin_src shell
xsser -u "http://victim" -g "/vulnerabilities/xss_r/?name=XSS" --auto --cookie="PHPSESSID=q26rlipdsjcmhavd0d1d43nb24; security=low"
#+end_src

- Và ta thấy Xsser cũng bị deny request 


#+DOWNLOADED: screenshot @ 2020-12-24 13:43:21
[[file:_assets/2020-12-24_13-43-21_screenshot.png]]


- Check log của modec:

#+DOWNLOADED: screenshot @ 2020-12-24 13:43:42
[[file:_assets/2020-12-24_13-43-42_screenshot.png]]
